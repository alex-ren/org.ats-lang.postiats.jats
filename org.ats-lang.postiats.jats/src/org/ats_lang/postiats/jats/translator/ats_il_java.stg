group ats_il_java;

program_st(filename, stats, main) ::= <<                 
package postiats;                                                   
                                                                                 

import org.ats_lang.postiats.jats.type.*;
import org.ats_lang.postiats.jats.value.*;
import org.ats_lang.postiats.jats.ccomp.*;   

import java.util.HashMap;
import java.util.Map;

public class <filename> {
    <stats; separator="\n\n">
    
    <main>
    
}


>>

stats_gvar_st(gvar) ::= <<
<if(gvar)>static public <gvar>;<endif>
>>

gvar_def_st(type, name, init) ::= <<
<type> <name> = <init>;
>>

elt_type_init_val_st() ::= <<
null
>>

ref_type_init_val_st(realty) ::= <<
<realty>.createRefDefault()
>>

nonref_type_init_val_st(ty) ::= <<
<ty>.createNormalDefault()
>>


stats_structtype_st(name, structtype_members) ::= <<
static StructType <name> = new StructType("<name>");
static {
    <structtype_members; separator="\n">
}
>>

structtype_members_st(name, id, type) ::= <<
<name>.addMember("<id>", <type>);
>>

fun_def_st(type, name, paras, body) ::= <<
static public <type> <name>(<paras>) {
    <body>
}
>>

paras_st(paras) ::= <<
<paras; separator=", ">
>>

para_st(type, name) ::= <<
<type> <name>
>>

block_st(bstats) ::= <<
<bstats; separator="\n">
>>

ifstatement_st (aifstat, aelseifstats, aelsestat) ::= <<
<aifstat><aelseifstats; separator="s"><aelsestat>
>>

ifstat_st(exp, block) ::= <<
if (<exp> == true) {
    <block>
} 
>>

elseifstat_st(exp, block) ::= <<
else if (<exp> == true) {
    <block>
} 
>>

elsestat_st(block) ::= <<
else {
    <block>
}
>>


fun_call_st(name, arglst) ::= <<
<name>(<arglst:{e |<e>}; separator=", ">)
>>

arg_st(type, arg) ::= <<
<arg>
>>

arg_copy_st(type_ins, type_java, arg) ::= <<
(<type_java>)RefType.cloneValue(<arg>, <type_ins>)
>>

atsins_move_ref_ref_st(tmp, val, type) ::= <<
RefType.updateFromRefType(<tmp>, <val>, <type>);
>>

atsins_move_ref_val_st(tmp, val, type) ::= <<
RefType.updateFromNonRefType(<tmp>, <val>, <type>);
>>

atsins_move_val_ref_st(tmp, val, type, type_java) ::= <<
<tmp> = (<type_java>)RefType.cloneValue(<val>, <type>);
>>

atsins_move_val_val_st(tmp, val, type) ::= <<
<tmp> = <val>;
>>

atsins_move_void_st(val) ::= <<
<if(val)><val>;<endif>
>>

ats_ck_iseqz_st(val) ::= <<
(<val> == 0)
>>

ats_dynload0_st(dyn_val) ::= <<
Integer <dyn_val> = 0;
>>

ats_return_st(val) ::= <<
return<if(val)> <val>;<else>;<endif>
>>

ats_return_copy_st(val, type) ::= <<
return<if(val)> xxxRefType.cloneValue(<val>, <type>);<else>;<endif>
>>

atsins_store_ref_ref_st(dst, src, type) ::= <<
RefType.updateFromRefType(<dst>, <src>, <type>);
>>

atsins_store_ref_val_st(dst, src, type) ::= <<
RefType.updateFromNonRefType(<dst>, <src>, <type>);
>>

atsins_move_boxrec_st(tmp) ::= <<
<tmp> = new HashMap\<String, Object>();
>>

atsins_move_boxrec_ref_st(tmp) ::= <<
RefType.updateFromNonRefType(<tmp>, new HashMap\<String, Object>(), BoxedType.cType);
>>

atsins_store_boxref_ofs_val_val_st(tmp, lab, val) ::= <<
<tmp>.put("<lab>", <val>);
>>

atsins_store_boxref_ofs_val_ref_st(tmp, lab, val, labtype) ::= <<
<tmp>.put("<lab>", RefType.cloneValue(<val>, <labtype>));
>>

atsins_store_boxref_ofs_ref_val_st(tmp, lab, val) ::= <<
((Map\<String, Object>)<tmp>.getValue(BoxedType.cType)).put("<lab>", <val>);
>>

atsins_store_boxref_ofs_ref_ref_st(tmp, lab, val, labtype) ::= <<
((Map\<String, Object>)<tmp>.getValue(BoxedType.cType)).put("<lab>", RefType.cloneValue(<val>, <labtype>));
>>

ats_sel_box_rec_st(pmv, lab, labty) ::= <<
(<labty>)<pmv>.get("<lab>")
>>

ats_sel_box_rec_ref_st(pmv, lab, labty) ::= <<
(<labty>)((Map\<String, Object>)RefType.getValue(<pmv>, BoxedType.cType)).get("<lab>")
>>

ats_sel_recsin_st(pmv, tyrec, lab) ::= <<
<pmv>
>>

ats_sel_flt_rec_st(pmv, lab, tylab_java) ::= <<
(<tylab_java>)<pmv>.get("<lab>")
>>

ats_sel_flt_rec_ref_st(pmv, lab, tyrec) ::= <<
RefType.SelFltrecOfs(<pmv>, "<lab>", <tyrec>)
>>

atsins_store_fltrec_ofs_val_val_st(tmp, tyrec, tylab, lab, val) ::= <<
<tmp>.put("<lab>", <val>);
>>

atsins_store_fltrec_ofs_val_ref_st(tmp, tyrec, tylab, lab, val) ::= <<
<tmp>.put("<lab>", RefType.cloneValue(<val>, <tylab>));
>>

atsins_store_fltrec_ofs_ref_val_st(tmp, tyrec, tylab, lab, val) ::= <<
RefType.updateFltrecOfs(<tmp>, <val>, "<lab>", <tyrec>);
>>

atsins_store_fltrec_ofs_ref_ref_st(tmp, tyrec, tylab, lab, val) ::= <<
RefType.updateFltrecOfs(<tmp>, RefType.getValue(<val>, <tylab>), "<lab>", <tyrec>);
>>


atsins_store_arrpsz_ptr_st(tmp, tyelt, tsz) ::= <<
<tmp>.init(<tsz>, <tyelt>);
>>

atsins_move_arrpsz_ptr_st(tmp, psz) ::= <<
<tmp> = ((ArrPsz) <psz>).getPtr();
>>

atsins_pmove_ref_st(tmp, hit, val, tyval) ::= <<
<tmp>.update(RefType.getValue(<val>, <tyval>), <hit>);
>>

atsins_pmove_st(tmp, hit, val, tyval) ::= <<
<tmp>.update(<val>, <hit>);
>>

atsins_update_ptrinc_st(tmp, sz) ::=<<
<tmp> = Ptrk.createPtrkOffset(<tmp>, <sz>);  
>>

ats_pvm_castfn_st(hit, exp) ::= <<
<!no op!>/*castfn_currently_no_op*/<exp>
>>

ats_pmv_sizeof_st(sz) ::= <<
<sz>
>>













identifier_st(id) ::= <<
<id>
>>

atom_exp_st(e) ::= <<
<e>
>>

string_exp_st(str) ::= <<
StringType.fromString(<str>)
>>

void_exp_st(e) ::= <<
SingletonValue.VOID
>>

main_args_convert_st() ::= <<
Integer mainArgc = args.length + 1;

Ptrk[] arrArgv = new Ptrk[mainArgc];
arrArgv[0] = StringType.fromString("<filename>");

for (int i = 1; i \< mainArgc; ++i) {
    arrArgv[i] = StringType.fromString(args[i - 1]);
}

ArrayType argvTy = new ArrayType(PtrkType.cType, mainArgc);

Ptrk mainArgv = Ptrk.createPtrk(argvTy, arrArgv);
>>

mainats_void_0_st(init_func) ::= <<
static public void main(String [] args) {
    <init_func>;
    mainats_void_0();
}
>>

mainats_argc_argv_0_st(init_func) ::= <<
static public void main(String [] args) {
    <init_func>;
    <main_args_convert_st()>
    mainats_argc_argv_0(mainArgc, mainArgv);
}
>>

mainats_argc_argv_envp_0_st(init_func) ::= <<
static public void main(String [] args) {
    <init_func>;
    <main_args_convert_st()>
    mainats_argc_argv_envp_0(mainArgc, mainArgv, null);
}
>>

mainats_void_int_st(init_func) ::= <<
static public void main(String [] args) {
    <init_func>;
    mainats_void_int();
}
>>

mainats_argc_argv_int_st(init_func) ::= <<
static public void main(String [] args) {
    <init_func>;
    <main_args_convert_st()>
    mainats_argc_argv_int(mainArgc, mainArgv);
}
>>

mainats_argc_argv_envp_int_st(init_func) ::= <<
static public void main(String [] args) {
    <init_func>;
    <main_args_convert_st()>
    mainats_argc_argv_envp_int(mainArgc, mainArgv, null);
}
>>

ats_ptrof_st(lval) ::= <<
RefType.ptrof(<lval>)
>>


// =======================================================


class_st(cls_name, cls_desc, body) ::= <<
private static class <cls_name> implements CCompCompositeValue {
    // line <cls_desc>
    <body>
}
>>

class_body_st(name_type_map, size) ::= <<

// size info
public static final int m_size = <size>;

// type info
public static class m_type {
    public static int getSize() {
        return m_size;
    }

    public static <cls_name> createDefault() {
        <cls_name> obj = new <cls_name>();
        <! obj.mem = IntValue.createDefault(); !>
        <name_type_map.keys:{k| obj.<k> = <name_type_map.(k)>.m_type.createDefault();}; separator="\n">

        return obj;
    }
}

// member info
<! IntValue mem; !>
<name_type_map.keys:{k| <var_decl_st(type={<name_type_map.(k)>}, name={<k>})>}; separator="\n">

// constructor
private <cls_name>() {
}

@Override
public void copyfrom(CCompCompositeValue v) {
    if (v instanceof <cls_name>) {
        <cls_name> from = (<cls_name>) v;
        <! this.mem.copyfrom(from.mem); !>
        <name_type_map.keys:{k| this.<k>.copyfrom(from.<k>);}; separator="\n">

    } else {
        throw new Error("Wrong type");
    }

}

@Override
public <cls_name> deepcopy() {
    <cls_name> obj = new <cls_name>();
    <! obj.mem = mem.deepcopy(); !>
    <name_type_map.keys:{k| obj.<k> = <k>.deepcopy();}; separator="\n">

    return obj;
}
>>



var_decl_st(type, name) ::= <<
public <type> <name>;
>>
// ========================================


new_prim_st(valuetype, content) ::= <<
<valuetype>.create(<content>)
>>


atsins_load_st(dest, cont) ::= <<
<dest>.copyfrom(<cont>);
>>























