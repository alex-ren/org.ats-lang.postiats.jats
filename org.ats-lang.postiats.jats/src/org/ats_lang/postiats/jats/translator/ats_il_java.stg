group ats_il_java;


program_t(filename, stats) ::= <<
public class <filename> {
    <stats; separator="\n\n">
}
>>


class_st(cls_name, cls_desc, body) ::= <<
private static class <cls_name> implements CCompCompositeValue {
    // line <cls_desc>
    <body>
}
>>

class_body_st(name_type_map, size) ::= <<

// size info
public static final int m_size = <size>;

// type info
public static class m_type {
    public static int getSize() {
        return m_size;
    }

    public static <cls_name> createDefault() {
        <cls_name> obj = new <cls_name>();
        <! obj.mem = IntValue.createDefault(); !>
        <name_type_map.keys:{k| obj.<k> = <name_type_map.(k)>.m_type.createDefault();}; separator="\n">

        return obj;
    }
}

// member info
<! IntValue mem; !>
<name_type_map.keys:{k| <var_decl_st(type={<name_type_map.(k)>}, name={<k>})>}; separator="\n">

// constructor
private <cls_name>() {
}

@Override
public void copyfrom(CCompCompositeValue v) {
    if (v instanceof <cls_name>) {
        <cls_name> from = (<cls_name>) v;
        <! this.mem.copyfrom(from.mem); !>
        <name_type_map.keys:{k| this.<k>.copyfrom(from.<k>);}; separator="\n">

    } else {
        throw new Error("Wrong type");
    }

}

@Override
public <cls_name> deepcopy() {
    <cls_name> obj = new <cls_name>();
    <! obj.mem = mem.deepcopy(); !>
    <name_type_map.keys:{k| obj.<k> = <k>.deepcopy();}; separator="\n">

    return obj;
}
>>

var_def_st(type, name) ::= <<
static public <type> <name> = <type>.m_type.createDefault();
>>


var_decl_st(type, name) ::= <<
static public <type> <name>;
>>

fun_def_st(type, name, paras, body) ::= <<
static public <type> <name>(<paras>) {
    <body>
}
>>

paras_st(paras) ::= <<
<paras; separator=",">
>>

para_st(type, name) ::= <<
<type> <name>
>>

fun_body_st(bstats) ::= <<
<bstats; separator="\n">
>>























