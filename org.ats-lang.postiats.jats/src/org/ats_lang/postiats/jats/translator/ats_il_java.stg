group ats_il_java;

main_no_arg_st() ::= <<
static public void main(String [] args) {
    mainats();
}
>>

main_args_st() ::= <<
static public void main(String [] args) {
    mainats()s;
}
>>

program_st(filename, stats, main) ::= <<                 
<! package postiats;                                                   !>
<!                                                                     !>
<! import org.ats_lang.postiats.jats.value.BoolValue;                  !>
<! import org.ats_lang.postiats.jats.value.CharValue;                  !>
<! import org.ats_lang.postiats.jats.value.IntValue;                   !>
<! import org.ats_lang.postiats.jats.value.ULIntValue;                 !>
<! import org.ats_lang.postiats.jats.value.SizeValue;                  !>
<! import org.ats_lang.postiats.jats.value.DoubleValue;                !>
<! import org.ats_lang.postiats.jats.value.StringValue;                !>
<! import org.ats_lang.postiats.jats.ccomp.CCompCompositeValue;        !>
<!                                                                     !>
<! import org.ats_lang.postiats.jats.ccomp.CCompTypedefs;              !>
<!                                                                     !>
<! import org.ats_lang.postiats.jats.ccomp.CCompArrayPtr;              !>
<! import org.ats_lang.postiats.jats.ccomp.CCompBasics;                !>
<! import org.ats_lang.postiats.jats.ccomp.CCompFloat;                 !>
<! import org.ats_lang.postiats.jats.ccomp.CCompInteger;               !>
<! import org.ats_lang.postiats.jats.ccomp.CCompString;                !>

public class <filename> {
    <stats; separator="\n\n">
    
    <main>
    
}


>>

stats_gvar_st(gvar) ::= <<
<if(gvar)>static public <gvar>;<endif>
>>

gvar_def_st(type, name, init) ::= <<
<type> <name> = <init>;
>>


stats_structtype_st(name, structtype_members) ::= <<
static StructType <name> = new StructType("<name>");
static {
    <structtype_members; separator="\n">
}
>>

structtype_members_st(name, id, type) ::= <<
<name>.addMember("<id>", <type>);
>>

fun_def_st(type, name, paras, body) ::= <<
static public <type> <name>(<paras>) {
    <body>
}
>>

paras_st(paras) ::= <<
<paras; separator=", ">
>>

para_st(type, name) ::= <<
<type> <name>
>>

block_st(bstats) ::= <<
<bstats; separator="\n">
>>

// =======================================================


class_st(cls_name, cls_desc, body) ::= <<
private static class <cls_name> implements CCompCompositeValue {
    // line <cls_desc>
    <body>
}
>>

class_body_st(name_type_map, size) ::= <<

// size info
public static final int m_size = <size>;

// type info
public static class m_type {
    public static int getSize() {
        return m_size;
    }

    public static <cls_name> createDefault() {
        <cls_name> obj = new <cls_name>();
        <! obj.mem = IntValue.createDefault(); !>
        <name_type_map.keys:{k| obj.<k> = <name_type_map.(k)>.m_type.createDefault();}; separator="\n">

        return obj;
    }
}

// member info
<! IntValue mem; !>
<name_type_map.keys:{k| <var_decl_st(type={<name_type_map.(k)>}, name={<k>})>}; separator="\n">

// constructor
private <cls_name>() {
}

@Override
public void copyfrom(CCompCompositeValue v) {
    if (v instanceof <cls_name>) {
        <cls_name> from = (<cls_name>) v;
        <! this.mem.copyfrom(from.mem); !>
        <name_type_map.keys:{k| this.<k>.copyfrom(from.<k>);}; separator="\n">

    } else {
        throw new Error("Wrong type");
    }

}

@Override
public <cls_name> deepcopy() {
    <cls_name> obj = new <cls_name>();
    <! obj.mem = mem.deepcopy(); !>
    <name_type_map.keys:{k| obj.<k> = <k>.deepcopy();}; separator="\n">

    return obj;
}
>>



var_decl_st(type, name) ::= <<
public <type> <name>;
>>
// ========================================


ifstatement_st (aifstat, aelseifstats, aelsestat) ::= <<
<aifstat><aelseifstats; separator="s"><aelsestat>
>>

ifstat_st(exp, block) ::= <<
if (<exp>.isTrue()) {
    <block>
}
>>

elseifstat_st(exp, block) ::= <<
 else if (<exp>.isTrue) {
    <block>
}
>>

elsestat_st(block) ::= <<
 else {
    <block>
}
>>

new_prim_st(valuetype, content) ::= <<
<valuetype>.create(<content>)
>>

fun_call_st (name, explst) ::= <<
<name>(<explst:{e |<e>.deepcopy()}; separator=", ">)
>>

atsins_load_st(dest, cont) ::= <<
<dest>.copyfrom(<cont>);
>>

atsins_store_st(dest, cont) ::= <<
<dest>.copyfrom(<cont>);
>>

atsins_store_arrpsz_asz_st(tmp, asz) ::= <<
<tmp>.size.copyfrom(<asz>);
>>

atsins_store_arrpsz_ptr_st(tmp, tyelt, tsz) ::= <<
<tmp>.ptr.m_elesz = <tyelt>.m_type.getSize();
<tmp>.ptr.m_arr = new <tyelt> [SizeValue.castFromV(<tsz>).getContent()];
for (int i = 0; i \< <tmp>.ptr.m_arr.length; ++i) {
    <tmp>.ptr.m_arr[i] = <tyelt>.m_type.createDefault();
}
<tmp>.ptr.m_ind = 0;
<tmp>.ptr.m_mem = <tmp>.ptr.m_arr[0];
>>

atsins_store_fltrec_ofs_st(tmp, tyrec, lab, val) ::= <<
<tmp>.<lab>.copyfrom(<val>);
>>

atsins_move_st(tmp, val) ::= <<
<tmp>.copyfrom(<val>);
>>

atsins_move_void_st(val) ::= <<
<if(val)><val>;<endif>
>>

atsins_pmove_st(tmp, hit, val) ::= <<
((<hit>) <tmp>.m_mem).copyfrom(<val>);
>>

atsins_move_arrpsz_ptr_st(tmp, psz) ::= <<
<tmp>.copyfrom(<psz>.ptr);
>>

atsins_update_ptrinc_st(tmp, tyelt) ::=<<
<tmp>.incIndex();
>>

ats_return_st(exp) ::= <<
return<if(exp)> <exp>.deepcopy();<else>;<endif>
>>

ats_pvm_castfn_st(hit, exp) ::= <<
<!no op!>/*castfn_currently_no_op*/<exp>
>>

ats_pmv_sizeof_st(type) ::= <<
SizeValue.create(<type>.m_type.getSize())
>>

ats_deref_st(pmv, hit) ::= <<
((<hit>) <pmv>.deRef())
>>

ats_ptrof_st(lval, type) ::= <<
CCompTypedefs.CPtrValue.create(<lval>, <type>.m_type.getSize())
>>

ats_sel_recsin_st(pmv, tyrec, lab) ::= <<
<pmv>
>>

ats_sel_flt_rec_st(pmv, tyrec, lab) ::= <<
(<pmv>).<lab>
>>

ats_sel_box_rec_st(pmv, tyrec, lab) ::= <<
((<tyrec>) (<pmv>.deRef())).<lab>
>>









