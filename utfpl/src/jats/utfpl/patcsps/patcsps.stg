group patcsps;

pmodel_st(scheduler_body, gvar_lst, proc_lst, thread_lst, main_proc_body) ::= <<

#import "PStack";

#import "MyLib";

// =====================

var\<PStack> GStack = new PStack();
var SysTid = 0;

channel SysChSch 0;
channel SysChSchStart 0;

createThread(par, fn, arg) = SysChSch!fn.arg -> Skip;

Scheduler = SysChSch?fn.arg ->
  initSch{SysTid++; var tid = SysTid; GStack.allocateStack(tid);} ->
  <scheduler_body>
  ;

  
SchedulerW (tid) = SysChSchStart?tid -> Scheduler;

// =====================

var mutex[10];  // 10 mutex
var mutex_count = 0;
channel mutex_req 0;
channel mutex_reply 0;

mutex_allocator = mutex_req?_ -> {mutex_count++} -> mutex_reply!mutex_count -> mutex_allocator;
mutex_allocate(tid) = mutex_req!1 -> mutex_reply?m -> { GStack.push(tid, m) } -> Skip;

mutex_lock(tid, m) = [mutex[m] == 0] mlock{mutex[m] = 1} -> Skip;

mutex_unlock(tid, m) = munlock{mutex[m] = 0} -> Skip;

// ======================

var cond_holder[10];  // 10 condition
channel cond_chan[10] 0;
var cond_count = 0;
channel cond_req 0;
channel cond_reply 0;

cond_allocator = cond_req?_ -> {cond_count++} -> cond_reply!cond_count -> cond_allocator;
cond_allocate(tid) = cond_req!1 -> cond_reply?m -> { GStack.push(tid, m) } -> Skip;

cond_wait(tid, c, m) = atomic{cadd{cond_holder[c]++;} -> mutex_unlock(tid, m); cond_chan[c]?_ -> mutex_lock(tid, m)};

cond_signal(tid, c) = atomic {if (cond_holder[c] > 0) {

          csub{cond_holder[c]--;} ->

          cond_chan[c]!1

          -> Skip

        }};

        

cond_broadcast(tid, c) = atomic{if (cond_holder[c] > 0) {

          signaln(c, cond_holder[c]); csub{cond_holder[c]=0;} -> Skip

        }};

signaln(c, n) = if (n > 0) {cond_chan[c]!1 -> signaln(c, n-1)}
                else {Skip}
                ;

// =====================

<gvar_lst; separator="\n">

<proc_lst; separator="\n\n">

<thread_lst; separator="\n">

main_s(tid) = 
  main_preloge {GStack.allocateStack(tid); <new_frame_st()>; <new_frame_st()>;} -> 
  <main_proc_body>;

main = main_s(0) ||| Scheduler ||| mutex_allocator ||| cond_allocator;


#assert main deadlockfree;

#define Prop1 (gn_22 \< 2);

#assert main |= G Prop1;

>>

pgdecvar_st(id, init) ::= <<
var <id><if(init)> = <init><endif>;
>>

pgdecarray_st(id, sz) ::= <<
var <id>[<sz>];
>>

pprocbranch_ifcommon_st(cond, if_proc, else_proc) ::= <<
if (<cond>) {
  <if_proc>
}<if(else_proc)> else {
  <else_proc>
}<endif>
>>

pprocbranch_ifa_st(cond, if_proc, else_proc) ::= <<
if (<cond>) {
  <if_proc>
}<if(else_proc)> else {
  <else_proc>
}<endif>
>>

pprocbranch_ifb_st(cond, if_proc, else_proc) ::= <<
if (<cond>) {
  <if_proc>
}<if(else_proc)> else {
  <else_proc>
}<endif>
>>
  
pevent_st(stat_lst) ::= <<
{  <stat_lst; separator="\n">
}
>>

pexpfunccall_st(fun_lab, arg_lst) ::= <<
call(<[fun_lab, arg_lst]; separator=", ">)
>>

pstatlocalvardec_st(name, val) ::= <<
var <name> = <val>;
>>

pstatassignment_st(name, val) ::= <<
<name> = <val>;
>>

pprocatom_st() ::= <<
Skip
>>

pproccall_st(name, arg_lst) ::= <<
<name>(<arg_lst; separator=", ">)
>>

pgdecproc_st(name, para_lst, body) ::= <<
<name>(<para_lst; separator=", ">) =
  <proc_preloge_st()> ->
  <body>
  ;
>>

pprocseq_st(proc_left, proc_right) ::= <<
<proc_left>;
<proc_right>
>>

pexpstackopr_default_t(frame, pos) ::= <<
GStack.get(tid, <frame>, <pos>)
>>

pexpstackopr_bool_t(frame, pos) ::= <<
GStack.getBool(tid, <frame>, <pos>)
>>

pprocevent_st(evt, proc) ::= <<
<evt> ->
<proc>
>>

pprocchannel_st(ch, proc) ::= <<
<ch> ->
<proc>
>>

pchannelrecv_st(name, ele_lst) ::= <<
<name>?<ele_lst; separator=".">
>>

pchannelsend_st(name, msg_lst) ::= <<
<name>!<msg_lst; separator=".">
>>

pexpopr_unary_st(exp, opr) ::= <<
<opr><exp>
>>

pexpopr_binary_st(exp1, exp2, opr) ::= <<
<exp1> <opr> <exp2>
>>

pprocparallel_st(proc_lst) ::= <<
<proc_lst; separator="\n|||\n">
>>

pstatstackpush_st(name) ::= <<
GStack.push(tid, <name>);
>>

pstatreturn_st(v) ::= <<
<delete_frame_st()>; GStack.push(tid, <v>);
>>

pnone_st() ::= <<
0
>>

pinscond_st(cond, trueb, falseb) ::= <<
if (cond) {
    <trueb; separator="\n">
} else {
    <falseb; separator="\n">
}
>>

pinsload_st(src, dst) ::= <<
var <dst> = <src>;
>> 

pinsloadarray_st(src, index, dst) ::= <<
<dst> = <src>[index];
>>

pinsstore_st(src, dst) ::= <<
<dst> = <src>;
>>

pinsstorearray_st(src, dst, index) ::= <<
<dst>[index] = src
>>

pinsmutexalloc_st(holder) ::= <<
var <holder> = atspat_mutex_alloc();
>>

// ================= 

new_frame_st() ::= <<
GStack.newFrame(tid)
>>

reload_frame_st() ::= <<
GStack.reloadFrame(tid)
>>

delete_frame_st() ::= <<
GStack.deleteFrame(tid)
>>

proc_preloge_st() ::= <<
preloge{
  if (isTailCall) {
    <reload_frame_st()>;
  } else {
    <new_frame_st()>;
  }
>>
//   <paras:{x| spush(tid, <x>)}; separator=";">}



















