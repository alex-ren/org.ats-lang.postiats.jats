group patcsps;

// ===============================

local_temp_list() ::= <<__temp_list_args>>

sys_gstack() ::= <<sys_gstack>>

sys_tid() ::= <<sys_tid>>

sys_cur_tid() ::= <<sys_cur_tid>>
sys_sch_tid() ::= <<-1>>
sys_new_tid() ::= <<sys_new_tid>>
sys_runable_list() ::= <<sys_runable_list>>
sys_runable_size() ::= <<sys_runable_size>>
sys_new_fn() ::= <<sys_new_fn>>
sys_new_args() ::= <<sys_new_args>>

sys_schedule_in() ::= <<[<sys_cur_tid()> == <sys_tid()>]>>
sys_schedule_out() ::= <<
if (<sys_glb()> == 0) {  // not atomic
  <sys_cur_tid()> = <sys_sch_tid()>;
}
>>

sys_ins_schedule_out_yes(has_effect) ::= <<
<if(has_effect)><sys_schedule_out()><else>...should not happen...<endif>
>>

sys_ins_schedule_out_no(has_effect) ::= <<
<if(has_effect)>...should not happen...<endif>
>>

sys_mylib() ::= <<sys_mylib_obj>>

atom_ref_manager() ::= <<atom_ref_manager>>

array_ref_manager() ::= <<array_ref_manager>>

view_manager() ::= <<view_manager>>

sys_mutex_manager() ::= <<
sys_mutex_manager
>>

sys_cond_manager() ::= <<
sys_cond_manager
>>

sys_assert_var() ::= <<
sys_assert_var
>>

sys_tid_allocator() ::= <<
sys_tid_allocator
>>

sys_glb() ::= <<
sys_glb
>>

sys_sch_thread_starter_st(proc1_name, proc1_addr, else_procs) ::= <<
sys_sch_thread_starter(tid, fn, args) = sys_sch_thread_starter_s1.tid{
    <sys_new_tid()> = -1;
    <sys_runable_list()> =  <sys_mylib()>.list_insert_ordered(tid, <sys_runable_list()>);
    <sys_runable_size()> = <sys_runable_size()> + 1;
    
    // Create a list with one element for stack
    var <local_temp_list()> = <sys_mylib()>.list_nil ();
    <local_temp_list()> = <sys_mylib()>.list_cons (args, <local_temp_list()>);
    <sys_gstack()>.add_frame(tid, <local_temp_list()>);
    
  } -> 
  <if(proc1_name)>ifa (fn == <proc1_addr>) {
    ([<sys_cur_tid()> == tid]<proc1_name>(tid);sys_thread_finalize(tid)) ||| sys_scheduler_random
  }
  <else_procs; separator="\n">
  else {
    Stop
  };
  <else>Skip<endif>
>>

sys_sch_thread_starter_else_if(proc_name, proc_addr) ::= <<
else ifa (fn == <proc_addr>) {
  ([<sys_cur_tid()> == tid]<proc_name>(tid);sys_thread_finalize(tid)) ||| sys_scheduler_random
}
>>

// ===============================

pmodel_st(scheduler_body, gvar_lst, proc_lst, main_proc_body, ext_code_lst) ::= <<

// ===============================

<!#import "PStack";!>
#import "MyLib";  // import the library

// =====================

// library data structure (e.g. tuple, list)
var\<MyLibObj> <sys_mylib()> = new MyLibObj();

// Set the initial capacity to 10.
var\<AtomRefManager> <atom_ref_manager()> = new AtomRefManager(10);

// Set the initial capacity to 10.
var\<ArrayRefManager> <array_ref_manager()> = new ArrayRefManager(10);

//
var\<ViewManager> <view_manager()> = new ViewManager();

// ====================
// For scheduler

// id of currrent running thread
var <sys_cur_tid()> = 0;

// list of runable threads
var <sys_runable_list()>;
var <sys_runable_size()>;

sys_runable_run_random(xs, n) = 
  ifa (n == 0) {sys_end -> Skip}
  else ifa (n == 1) {
    sys_run_first_one(xs)
  }
  else {
    sys_run_first_one(xs)
    \<>
    sys_runable_run_random(<sys_mylib()>.list_get_tail(xs), n - 1)
  };

var sys_show_cur_tid;

sys_run_first_one(xs) = get_cur_tid{sys_show_cur_tid = <sys_mylib()>.list_get_header(xs);} ->
  sys_run_first_one_scheduleto.sys_show_cur_tid.<sys_runable_size()>{<sys_cur_tid()> = <sys_mylib()>.list_get_header(xs);
  } -> 
  sys_scheduler_random
  ;

var <sys_new_tid()>;  // indicator for creating new thread
var <sys_new_fn()>;
var <sys_new_args()>;

sys_scheduler_random = [<sys_cur_tid()> == <sys_sch_tid()>](
  ifa (<sys_new_tid()> == -1) {  // schedule
    sys_runable_run_random(<sys_runable_list()>, <sys_runable_size()>)
  } else {  // create new thread
    sys_sch_thread_starter(<sys_new_tid()>, <sys_new_fn()>, <sys_new_args()>)
  });


<scheduler_body>  // sys_sch_thread_starter
  
sys_thread_finalize(<sys_tid()>) = [<sys_cur_tid()> == <sys_tid()>] sys_thread_finalize_s1.<sys_tid()>{
    // finalize thread
    // remove tid
    <sys_my_lib()>.print_list(0, <sys_runable_list()>);
    <sys_runable_list()> = <sys_mylib()>.list_remove_element(<sys_runable_list()>, <sys_tid()>);
    <sys_my_lib()>.print_list(1, <sys_runable_list()>);
    <sys_runable_size()> = <sys_runable_size()> - 1;
    <sys_cur_tid()> = <sys_sch_tid()>;  // schedule out
  } -> Skip;

sys_thread_create(<sys_tid()>, tid, fn, args) = [<sys_cur_tid()> == <sys_tid()>] sys_thread_create_s1.<sys_tid()>{
    <sys_new_tid()> = tid;
    <sys_new_fn()> = fn;
    <sys_new_args()> = args;
  
    <sys_cur_tid()> = <sys_sch_tid()>;
  } -> Skip;
  
// =====================
// For global exclusion.
var <sys_glb()> = 0;

// =====================

// Stack Operation
var\<PStack> <sys_gstack()> = new PStack();

// thread id allocator
var\<Allocator> <sys_tid_allocator()> = new Allocator();  // todo: improve

// =====================

// Set the initial capacity to 10.
#define MUTEX_NO  10;
var\<Allocator> <sys_mutex_manager()> = new Allocator();

// ====================

var sys_mutex_repo = [-1(MUTEX_NO)];
var\<AtomRefManager> sys_mutex_waiting_list_manager = new AtomRefManager(MUTEX_NO);

sys_init_mutex_service(n) = sys_init_mutex_service_s1{
  sys_mutex_waiting_list_manager.initialize(n, <sys_mylib()>.list_nil());
} -> Skip;

sys_mutex_acquire(<sys_tid()>, m) = 
  ifa (sys_mutex_repo[m] == -1) {  // can have the mutex
    sys_mutex_acquire_yes.<sys_tid()>{sys_mutex_repo[m] = <sys_tid()>;} -> Skip
  } else {
   sys_mutex_acquire_no.<sys_tid()>{  // cannot have the mutex
      // remove current thread from runable
      <sys_runable_list()> = <sys_mylib()>.list_remove_element(<sys_runable_list()>, <sys_tid()>);
      <sys_runable_size()> = <sys_runable_size()> - 1;
      
      // add current thread to waiting list
      var <local_temp_list()> = 
        <sys_mylib()>.list_insert_ordered(<sys_tid()>, sys_mutex_waiting_list_manager.getElement(m));
      sys_mutex_waiting_list_manager.setElement(m, <local_temp_list()>);
      
      <sys_cur_tid()> = <sys_sch_tid()>;  // schedule out
    } -> Skip
  }
  ;

sys_mutex_release(<sys_tid()>, m) = 
  ifa(<sys_mylib()>.list_is_nil(sys_mutex_waiting_list_manager.getElement(m))) {
    sys_mutex_release_s1.<sys_tid()>{
      sys_mutex_repo[m] = -1;
      <sys_cur_tid()> = <sys_sch_tid()>;  // schedule out
    } -> Skip
  } else {
    sys_mutex_release_random(<sys_tid()>, m, sys_mutex_waiting_list_manager.getElement(m))
  }

sys_mutex_release_random(<sys_tid()>, m, waiting_list) = 
  ifa (<sys_mylib()>.list_is_nil(<sys_mylib()>.list_get_tail(waiting_list))) {
    sys_mutex_release_random_first(<sys_tid()>, m, <sys_mylib()>.list_get_header(waiting_list))
  } else {
    sys_mutex_release_random_first(<sys_tid()>, m, <sys_mylib()>.list_get_header(waiting_list))
    \<>
    sys_mutex_release_random(<sys_tid()>, m, <sys_mylib()>.list_get_tail(waiting_list))
  }
  ;
  
sys_mutex_release_random_first(<sys_tid()>, m, tid) = {
  // remove from waiting list
  var waiting_list = sys_mutex_waiting_list_manager.getElement(m);
  var new_list = <sys_mylib()>.list_remove_element(waiting_list, tid);
  sys_mutex_waiting_list_manager.setElement(m, new_list);
  
  sys_mutex_repo[m] = tid;
  
  // add to runable
  <sys_runable_list()> = <sys_mylib()>.list_insert_ordered(tid, <sys_runable_list()>);
  <sys_runable_size()> = <sys_runable_size()> + 1;
  
  <sys_cur_tid()> = <sys_sch_tid()>;  // schedule out
  } -> Skip;

// ====================

conats_mutex_acquire(<sys_tid()>) = 
  <sys_schedule_in()> 
  sys_mutex_acquire(<sys_tid()>, <sys_gstack()>.frame_get(<sys_tid()>, 0, 0));

conats_mutex_release(<sys_tid()>) = 
  <sys_schedule_in()> 
  sys_mutex_release (<sys_tid()>, <sys_gstack()>.frame_get(<sys_tid()>, 0, 0));

// =================================
// Set the initial capacity to 10.
#define COND_NO  10;
var\<Allocator> <sys_cond_manager()> = new Allocator();

// ======================

var sys_cond_repo = [0(COND_NO)];
var\<AtomRefManager> sys_cond_sleep_list_manager = new AtomRefManager(COND_NO);

// ======================

sys_init_cond_service(n) = sys_init_cond_service_s1{
  sys_cond_sleep_list_manager.initialize(n, <sys_mylib()>.list_nil());
} -> Skip;


sys_cond_signal(<sys_tid()>, c, m) = 
  ifa(<sys_mylib()>.list_is_nil(sys_cond_sleep_list_manager.getElement(c))) {
    sys_cond_signal_empty.<sys_tid()> -> Skip
  } else {
    sys_cond_signal_random(<sys_tid()>, c, sys_cond_sleep_list_manager.getElement(c))
  }

sys_cond_signal_random(<sys_tid()>, c, sleep_list) = 
  ifa (<sys_mylib()>.list_is_nil(<sys_mylib()>.list_get_tail(sleep_list))) {
    sys_cond_signal_random_first(<sys_tid()>, c, <sys_mylib()>.list_get_header(sleep_list))
  } else {
    sys_cond_signal_random_first(<sys_tid()>, c, <sys_mylib()>.list_get_header(sleep_list))
    \<>
    sys_cond_signal_random(<sys_tid()>, c, <sys_mylib()>.list_get_tail(sleep_list))
  }
  ;
  
sys_cond_signal_random_first(<sys_tid()>, c, tid) = sys_cond_signal_random_first_s1.<sys_tid()>{
  // remove from sleep list
  var sleep_list = sys_cond_sleep_list_manager.getElement(c);
  var new_list = <sys_mylib()>.list_remove_element(sleep_list, tid);
  sys_cond_sleep_list_manager.setElement(c, new_list);
  
  // add to runable
  <sys_runable_list()> = <sys_mylib()>.list_insert_ordered(tid, <sys_runable_list()>);
  <sys_runable_size()> = <sys_runable_size()> + 1;
  } -> Skip;

sys_cond_wait(<sys_tid()>, c, m) = sys_cond_wait_s1.<sys_tid()>{
  // remove from runable
  <sys_runable_list()> = <sys_mylib()>.list_remove_element(<sys_runable_list()>, <sys_tid()>);
  <sys_runable_size()> = <sys_runable_size()> - 1;
  // add to sleep
  var new_list = <sys_mylib()>.list_insert_ordered(<sys_tid()>, sys_cond_sleep_list_manager.getElement(c));
  sys_cond_sleep_list_manager.setElement(c, new_list);
  } -> Skip;
  // release mutex. This would cause schedule out
  sys_mutex_release(<sys_tid()>, m);
  <sys_schedule_in()>  // schedule in
  sys_mutex_acquire(<sys_tid()>, m);

sys_cond_broadcast(<sys_tid()>, c) = sys_cond_broadcast_s1{
  var sleep_list = sys_cond_sleep_list_manager.getElement(c);
  <sys_runable_list()> = <sys_mylib()>.list_merge_ordered(<sys_runable_list()>, sleep_list);
  <sys_runable_size()> = <sys_runable_size()> + <sys_mylib()>.list_length(sleep_list);
  sys_cond_sleep_list_manager.setElement(c, <sys_mylib()>.list_nil());
  } -> Skip;

// ======================

conats_shared_acquire(<sys_tid()>) = 
  <sys_schedule_in()>
  conats_shared_acquire_impl(<sys_tid()>, <sys_gstack()>.frame_get(<sys_tid()>, 0, 0));
 
//  tup = <sys_gstack()>.frame_get(<sys_tid()>, 0, 0)
//  a = <sys_mylib()>.getTupleElement(tup, 0);
//  mutex = <sys_mylib()>.getTupleElement(tup, 1);
//  cond = <sys_mylib()>.getTupleElement(tup, 2);
conats_shared_acquire_impl(<sys_tid()>, tup) =
    conats_shared_acquire_impl_s1.<sys_tid()>{
      <sys_gstack()>.frame_push(<sys_tid()>, <sys_mylib()>.getTupleElement(tup, 0))  // return a
    } ->
    sys_mutex_acquire(<sys_tid()>, <sys_mylib()>.getTupleElement(tup, 1))
    ;

// ====================

conats_shared_release(<sys_tid()>) = 
  <sys_schedule_in()> 
  conats_shared_release_impl(<sys_tid()>, 
                             <sys_gstack()>.frame_get(<sys_tid()>, 0, 0),
                             <sys_gstack()>.frame_get(<sys_tid()>, 0, 1)
                            );
                                          
conats_shared_release_impl(<sys_tid()>, tup, a) = 
  sys_mutex_release(<sys_tid()>, <sys_mylib()>.getTupleElement(tup, 1));

// ====================

conats_shared_signal(<sys_tid()>) = 
  <sys_schedule_in()>
  conats_shared_signal_impl(<sys_tid()>, <sys_gstack()>.frame_get(<sys_tid()>, 0, 0), 0);


conats_sharedn_signal(<sys_tid()>) = 
  <sys_schedule_in()>
  conats_shared_signal_impl(<sys_tid()>, <sys_gstack()>.frame_get(<sys_tid()>, 0, 0), 
                                            <sys_gstack()>.frame_get(<sys_tid()>, 0, 1));

conats_shared_signal_impl(<sys_tid()>, tup, index) = sys_cond_signal(<sys_tid()>, 
                                  <sys_mylib()>.getTupleElement(tup, index + 2),  // cond
                                  <sys_mylib()>.getTupleElement(tup, 1));  // mutex

// ====================

conats_shared_condwait(<sys_tid()>) = 
  <sys_schedule_in()>
  conats_shared_condwait_impl(<sys_tid()>, <sys_gstack()>.frame_get(<sys_tid()>, 0, 0), 0);

conats_sharedn_condwait(<sys_tid()>) = 
  <sys_schedule_in()>
  conats_shared_condwait_impl(<sys_tid()>, <sys_gstack()>.frame_get(<sys_tid()>, 0, 0), 
                                              <sys_gstack()>.frame_get(<sys_tid()>, 0, 1));
    
conats_shared_condwait_impl(<sys_tid()>, tup, index) = sys_cond_wait(<sys_tid()>, 
                                  <sys_mylib()>.getTupleElement(tup, index + 2),  // cond
                                  <sys_mylib()>.getTupleElement(tup, 1));  // mutex

// ====================

conats_shared_broadcast(<sys_tid()>) = 
  <sys_schedule_in()>
  conats_shared_broadcast_impl(<sys_tid()>, <sys_gstack()>.frame_get(<sys_tid()>, 0, 0), 0);

conats_sharedn_broadcast(<sys_tid()>) = 
  <sys_schedule_in()>
  conats_shared_broadcast_impl(<sys_tid()>, <sys_gstack()>.frame_get(<sys_tid()>, 0, 0), 
                                               <sys_gstack()>.frame_get(<sys_tid()>, 0, 1));

conats_shared_broadcast_impl(<sys_tid()>, tup, index) = 
    sys_cond_broadcast(<sys_tid()>, <sys_mylib()>.getTupleElement(tup, index + 2));

// ===============================
// global variable for assertion
var <sys_assert_var()> = true;

// =====================

<gvar_lst; separator="\n">

<proc_lst; separator="\n\n">

// =====================

sys_main(<sys_tid()>) = <sys_schedule_in()>
  sys_main_init.<sys_tid()>{var <local_temp_list()> = <sys_mylib()>.list_nil ();
            <sys_gstack()>.add_frame(0, <local_temp_list()>); 
            } -> Skip;
  <main_proc_body>; 
  sys_thread_finalize(<sys_tid()>);

var main_sys_tid = <sys_tid_allocator()>.allocate();
main = 
  sys_init_mutex_service(MUTEX_NO);
  sys_init_cond_service(COND_NO);
  main_init_scheduler {  // initialize runable
  var <local_temp_list()> = <sys_mylib()>.list_nil ();
  <local_temp_list()> = <sys_mylib()>.list_insert_ordered(main_sys_tid, <local_temp_list()>);
  <sys_runable_list()> = <local_temp_list()>;
  <sys_runable_size()> = 1;
  <sys_cur_tid()> = main_sys_tid;
  
  <sys_new_tid()> = -1;  // -1: not creating new thread
  } -> (sys_main(main_sys_tid) ||| sys_scheduler_random);

#define sys_assertion <sys_assert_var()> == true;

// #assert main deadlockfree;

// #assert main |= G sys_assertion;

<ext_code_lst; separator="\n\n">


>>

PGDecVar_st(id, init) ::= <<
var <id><if(init)> = <init><endif>;
>>

pgdecarray_st(id, sz) ::= <<
var <id>[<sz>];
>>

pprocbranch_ifcommon_st(cond, if_proc, else_proc) ::= <<
if (<cond>) {
  <if_proc>
}<if(else_proc)> else {
  <else_proc>
}<endif>
>>

pprocbranch_ifa_st(cond, if_proc, else_proc) ::= <<
ifa (<cond>) {
  <if_proc>
}<if(else_proc)> else {
  <else_proc>
}<endif>
>>

pprocbranch_ifb_st(cond, if_proc) ::= <<
ifb (<cond>) {
  <if_proc>
}
>>
  
pevent_st(tag, stat_lst) ::= <<
<sys_schedule_in()> <tag>.<sys_tid()>{  <stat_lst; separator="\n">
} -> Skip
>>

PExpFuncCall_st(is_sym, fun_lab, arg_lst) ::= <<
<if(is_sym)>call(<[fun_lab, arg_lst]; separator=", ">)<else><sys_mylib()>.<fun_lab>(<arg_lst; separator=", ">)<endif>
>>

PStatLocalVarDec_st(name, val, is_global) ::= <<
<if(name)><if(is_global)><else>var <endif><name><if(val)> = <endif><endif><if(val)><val><endif>;
>>

PStatAssignment_st(name, val) ::= <<
<if(name)><name> = <endif><val>;
>>

pprocatom_st() ::= <<
Skip
>>

pproccall_st(name) ::= <<
<name>(<sys_tid()>)
>>

pgdecproc_st(name, para_lst, body) ::= <<
<name>(<sys_tid()>) =
<!  <proc_preloge_st()> ->  !>
  <body>
  ;
>>

pprocseq_st(proc_left, proc_right) ::= <<
<proc_left>;
<proc_right>
>>

pexpstackopr_default_t(frame, pos) ::= <<
<sys_gstack()>.frame_get(<sys_tid()>, <frame>, <pos>)
>>

pexpstackopr_bool_t(frame, pos) ::= <<
<sys_gstack()>.frame_get_bool(<sys_tid()>, <frame>, <pos>)
>>

pexpstackopr_int_t(frame, pos) ::= <<
<sys_gstack()>.frame_get(<sys_tid()>, <frame>, <pos>)
>>

pprocevent_st(evt, proc) ::= <<
<evt>;
<proc>
>>

pprocchannel_st(ch, proc) ::= <<
<ch> ->
<proc>
>>

pchannelrecv_st(name, ele_lst) ::= <<
<name>?<ele_lst; separator=".">
>>

pchannelsend_st(name, msg_lst) ::= <<
<name>!<msg_lst; separator=".">
>>

pexpopr_unary_st(exp, opr) ::= <<
<opr><exp>
>>

pexpopr_binary_st(exp1, exp2, opr) ::= <<
<exp1> <opr> <exp2>
>>

pprocparallel_st(proc_lst) ::= <<
<proc_lst; separator="\n|||\n">
>>

pstatstackpush_st(name) ::= <<
<sys_gstack()>.frame_push(<sys_tid()>, <name>);
>>

pstatreturn_st(v) ::= <<
<sys_gstack()>.frame_push(<sys_tid()>, <v>);
>>

pnone_st() ::= <<
0
>>

pinscond_st(cond, trueb, falseb) ::= <<
if (<cond>) {
    <trueb; separator="\n">
} else {
    <falseb; separator="\n">
}
>>


PInsMutexCreate_st(holder, is_global, has_effect) ::= <<
<if(is_global)><else>var <endif><holder> = <sys_mutex_manager()>.allocate();
<sys_ins_schedule_out_no(has_effect)>
>>

// pinsmutexrelease_st(mutex) ::= <<
// <sys_mutex_manager()>.release(<mutex>);
// >>

pinscondalloc_st(holder, is_global) ::= <<
<if(is_global)><else>var <endif><holder> = <sys_cond_manager()>.allocate();
>>

PInsMCAssert_st(pred, has_effect) ::= <<
<sys_assert_var()> = <pred>;
<sys_ins_schedule_out_yes(has_effect)>
>>

// pinscondrelease_st(cond) ::= <<
// <sys_cond_manager()>.release(<cond>);
// >>

PProcThreadCreate_st(tid, funaddr, args) ::= <<
sys_thread_create(<sys_tid()>, <tid>, <funaddr>, <args>)
>>

PStatProcCallPrelogue_st(args, is_tail_call) ::= <<
var <local_temp_list()> = <sys_mylib()>.list_nil ();
<args:{arg|<local_temp_list()> = <sys_mylib()>.list_cons (<arg>, <local_temp_list()>);}; separator="\n">
<if(is_tail_call)><sys_gstack()>.reload_frame(<sys_tid()>, <local_temp_list()>);<else><sys_gstack()>.add_frame(<sys_tid()>, <local_temp_list()>);<endif>
>>

PStatProcCallEpilogue_st(is_void, ret, is_global) ::= <<
<if(is_void)><sys_gstack()>.delete_frame(<sys_tid()>);<else><if(ret)><if(is_global)><else>var <endif><ret> = <endif><sys_gstack()>.retopr_frame(<sys_tid()>);<endif>
>>

// ===================================================

PExpFormClosure_st(funaddr, envname) ::= <<
<sys_mylib()>.createTuple2(<funaddr>, <envname>)
>>

PExpPatLabDecompose_st(tup, index) ::= <<
<sys_mylib()>.getTupleElement(<tup>, <index>)
>>

PExpTupleCreate_st(len) ::= <<
<sys_mylib()>.createTuple(<len>)
>>

PInsTupleAdd_st(tupname, index, e) ::= <<
<sys_mylib()>.setTupleElement(<tupname>, <index>, <e>);
>>

PInsAtomRefCreate_st(holder, init, is_global, has_effect) ::= <<
<if(is_global)><else>var <endif><holder> = <atom_ref_manager()>.allocate(<init>);
<sys_ins_schedule_out_no(has_effect)>
>>

PInsAtomRefGet_st(holder, ref, is_global, has_effect) ::= <<
<if(is_global)><else>var <endif><holder> = <atom_ref_manager()>.getElement(<ref>);
<sys_ins_schedule_out_yes(has_effect)>
>>

PInsAtomRefUpdate_st(ref, exp, has_effect) ::= <<
<atom_ref_manager()>.setElement(<ref>, <exp>);
<sys_ins_schedule_out_yes(has_effect)>
>>


PInsArrayRefCreate_st(holder, len, init, is_global, has_effect) ::= <<
<if(is_global)><else>var <endif><holder> = <array_ref_manager()>.allocate(<len>, <init>);
<sys_ins_schedule_out_no(has_effect)>
>>

PInsArrayRefGet_st(holder, ref, pos, is_global, has_effect) ::= <<
<if(is_global)><else>var <endif><holder> = <array_ref_manager()>.getElement(<ref>, <pos>);
<sys_ins_schedule_out_yes(has_effect)>
>>

PInsArrayRefUpdate_st(ref, pos, exp, has_effect) ::= <<
<array_ref_manager()>.setElement(<ref>, <pos>, <exp>);
<sys_ins_schedule_out_yes(has_effect)>
>>

PInsTIdAllocate_st(holder, is_global, has_effect) ::= <<
<if(is_global)><else>var <endif><holder> = <sys_tid_allocator()>.allocate();
<sys_ins_schedule_out_no(has_effect)>
>>

PInsMCSet_st(gv, v) ::= <<
<gv> = <v>;
<sys_ins_schedule_out_yes(true)>
>>

PInsMCGet_st(holder, gv) ::= <<
var <holder> = <gv>;
<sys_ins_schedule_out_yes(true)>
>>

PInsMCVLockViewGet_st(args, holder) ::= <<
var <holder> = <view_manager()>.get(<args; separator=", ">);
sys_assert_var = !<sys_mylib()>.is_none(<holder>);
>>

PInsMCVLockViewPut_st(v) ::= <<
<view_manager()>.put(<v>);
>>

PInsSharedCreate_st(holder, v, n, is_global, has_effect) ::= <<
var bound = <n> + 2;
<if(is_global)><else>var <endif><holder> = <sys_mylib()>.createTuple(bound);
<sys_mylib()>.setTupleElement(<holder>, 0, <v>);  // value
<sys_mylib()>.setTupleElement(<holder>, 1, <sys_mutex_manager()>.allocate());  // mutex
var index = 2;
while (index \< bound) {
    <sys_mylib()>.setTupleElement(<holder>, index, <sys_cond_manager()>.allocate());
    index = index + 1;
};
<sys_ins_schedule_out_no(has_effect)>
>>

PInsMCAtomicStart_st() ::= <<
<sys_glb()> = 1;
>>

PInsMCAtomicEnd_st() ::= <<
<sys_glb()> = 0;
>>










