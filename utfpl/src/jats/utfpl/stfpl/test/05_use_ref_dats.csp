// ===============================

#import "MyLib";  // import the library

// =====================

// library data structure (e.g. tuple, list)
var<MyLibObj> sys_mylib_obj = new MyLibObj();

// Set the initial capacity to 10.
var<AtomRefManager> atom_ref_manager = new AtomRefManager(10);

// Set the initial capacity to 10.
var<ArrayRefManager> array_ref_manager = new ArrayRefManager(10);

//
var<ViewManager> view_manager = new ViewManager();

// ====================
// For scheduler

// id of currrent running thread
var sys_cur_tid = 0;

// list of runable threads
var sys_runable_list;
var sys_runable_size;

sys_runable_run_random(xs, n) = 
  ifa (n == 0) {Skip}
  else ifa (n == 1) {
    sys_run_first_one(xs)
  }
  else {
    sys_run_first_one(xs)
    <>
    sys_runable_run_random(sys_mylib_obj.list_get_tail(xs), n - 1)
  };

sys_run_first_one(xs) = 
  sys_run_first_one_s1{sys_cur_tid = sys_mylib_obj.list_get_header(xs);
  } -> 
  sys_scheduler_random
  ;

var sys_new_tid;  // indicator for creating new thread
var sys_new_fn;
var sys_new_args;

sys_scheduler_random = [sys_cur_tid == -1](
  ifa (sys_new_tid == -1) {  // schedule
    sys_runable_run_random(sys_runable_list, sys_runable_size)
  } else {  // create new thread
    sys_sch_thread_starter(sys_new_tid, sys_new_fn, sys_new_args)
  });


sys_sch_thread_starter(tid, fn, args) = sys_sch_thread_starter_s1{
    sys_new_tid = -1;
    sys_runable_list =  sys_mylib_obj.list_cons(tid, sys_runable_list);
    sys_runable_size = sys_runable_size + 1;

    // Create a list with one element for stack
    var __temp_list_args = sys_mylib_obj.list_nil ();
    __temp_list_args = sys_mylib_obj.list_cons (args, __temp_list_args);
    sys_gstack.add_frame(tid, __temp_list_args);

  } -> 
  Skip  // sys_sch_thread_starter

sys_thread_finalize(sys_tid) = [sys_cur_tid == sys_tid] sys_thread_finalize_s1.sys_tid{
    // finalize thread
    // remove tid
    sys_runable_list = sys_mylib_obj.list_remove_element(sys_runable_list, sys_tid);
    sys_runable_size = sys_runable_size - 1;
    sys_cur_tid = -1;  // schedule out
  } -> Skip;

sys_thread_create(sys_tid, tid, fn, args) = [sys_cur_tid == sys_tid] sys_thread_create_s1.sys_tid{
    sys_new_tid = tid;
    sys_new_fn = fn;
    sys_new_args = args;

    sys_cur_tid = -1;
  } -> Skip;

// =====================
// For global exclusion.
var sys_glb = 0;

// =====================

// Stack Operation
var<PStack> sys_gstack = new PStack();

// thread id allocator
var<Allocator> sys_tid_allocator = new Allocator();  // todo: improve

// =====================

// =====================

var mutex[10];  // 10 mutex

var<Allocator> sys_mutex_manager = new Allocator();

// ====================
conats_mutex_acquire(sys_tid) = sys_mutex_lock_impl (sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));

sys_mutex_lock_impl(sys_tid, m) = [mutex[m] == 0] mlock.sys_tid{mutex[m] = 1} -> Skip;
// ====================
conats_mutex_release(sys_tid) = sys_mutex_unlock_impl (sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));

sys_mutex_unlock_impl(sys_tid, m) = sys_munlock.sys_tid{mutex[m] = 0} -> Skip;
// ======================

var cond_holder[10];  // 10 condition

var<Allocator> sys_cond_manager = new Allocator();

channel cond_chan[10] 0;
var cond_count = 0;

// ====================

conats_shared_acquire(sys_tid) = conats_shared_acquire_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));
//  tup = sys_gstack.frame_get(sys_tid, 0, 0)
//  a = sys_mylib_obj.getTupleElement(tup, 0);
//  mutex = sys_mylib_obj.getTupleElement(tup, 1);
//  cond = sys_mylib_obj.getTupleElement(tup, 2);
conats_shared_acquire_impl(sys_tid, tup) = // atomic{ // Cannot use atomic here. Otherwise it would cause higher priority.
    shared_acq.sys_tid{sys_gstack.frame_push(sys_tid, sys_mylib_obj.getTupleElement(tup, 0))} ->
    sys_mutex_lock_impl(sys_tid, sys_mylib_obj.getTupleElement(tup, 1))
    // }  // end of atomic
    ;
// ====================
conats_shared_release(sys_tid) = conats_shared_release_impl(sys_tid, 
                                          sys_gstack.frame_get(sys_tid, 0, 0),
                                          sys_gstack.frame_get(sys_tid, 0, 1)
                                          );

conats_shared_release_impl(sys_tid, tup, a) = 
    sys_mutex_unlock_impl(sys_tid, sys_mylib_obj.getTupleElement(tup, 1));
// ====================
conats_shared_signal(sys_tid) = conats_shared_signal_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), 0);
conats_sharedn_signal(sys_tid) = conats_shared_signal_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), sys_gstack.frame_get(sys_tid, 0, 1));

conats_shared_signal_impl(sys_tid, tup, index) = 
    sys_cond_signal_impl(sys_tid, sys_mylib_obj.getTupleElement(tup, index + 2));

sys_cond_signal_impl(sys_tid, c) = atomic {if (cond_holder[c] > 0) {  // I think it's safe to keep *atomic* here.

          csub.sys_tid{cond_holder[c]--;} ->

          cond_chan[c]!1

          -> Skip

        }};    
// ====================

conats_shared_condwait(sys_tid) = 
    conats_shared_condwait_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), 0);

conats_sharedn_condwait(sys_tid) = 
    conats_shared_condwait_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), sys_gstack.frame_get(sys_tid, 0, 1));

conats_shared_condwait_impl(sys_tid, tup, index) = sys_cond_wait_impl(sys_tid, 
                                  sys_mylib_obj.getTupleElement(tup, index + 2),  // cond
                                  sys_mylib_obj.getTupleElement(tup, 1));  // mutex

sys_cond_wait_impl(sys_tid, c, m) = atomic{
  cadd.sys_tid{cond_holder[c]++;} -> 
  sys_mutex_unlock_impl(sys_tid, m); 
  cond_chan[c]?_ -> Skip }; 
  sys_mutex_lock_impl(sys_tid, m)  // Cannot use atomic here. Otherwise it would cause current thread has higher priority to lock.
  ;

// ====================

conats_shared_broadcast(sys_tid) = conats_shared_broadcast_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), 0);
conats_sharedn_broadcast(sys_tid) = conats_shared_broadcast_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), sys_gstack.frame_get(sys_tid, 0, 1));


conats_shared_broadcast_impl(sys_tid, tup, index) = 
    sys_cond_broadcast_impl(sys_tid, sys_mylib_obj.getTupleElement(tup, index + 2));

sys_cond_broadcast_impl(sys_tid, c) = atomic{if (cond_holder[c] > 0) {  // It's safe to use *atomic* here.

          sys_signaln(c, cond_holder[c]); csub{cond_holder[c]=0;} -> Skip

        }};

sys_signaln(c, n) = if (n > 0) {cond_chan[c]!1 -> sys_signaln(c, n-1)}
                else {Skip}
                ;

// ===============================

// #define sys_list_nil  sys_list_manager.list_nil ();
// #define sys_list_cons(x, xs) sys_list_manager.list_cons (x, xs);
// #define sys_list_get_header(xs) sys_list_manager.list_get_header (xs);
// #define sys_list_get_tail(xs) sys_list_manager.list_get_tail (xs);
// #define sys_list_is_nil(xs) sys_list_manager.list_is_nil (xs);

// ===============================
// global variable for assertion
var sys_assert_var = true;

// =====================

var g_63 = 0;
var x_64 = 0;


// =====================

sys_main(sys_tid) = [sys_cur_tid == sys_tid]
  sys_main_init.sys_tid{var __temp_list_args = sys_mylib_obj.list_nil ();
            sys_gstack.add_frame(0, __temp_list_args); 
            } -> Skip;
  [sys_cur_tid == sys_tid] main5_id_s1.sys_tid{  g_63 = atom_ref_manager.allocate(0);

  atom_ref_manager.setElement(g_63, 3);
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  } -> Skip;
  [sys_cur_tid == sys_tid] main5_id_s2.sys_tid{  x_64 = atom_ref_manager.getElement(g_63);
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  } -> Skip;
  [sys_cur_tid == sys_tid] main5_id_s3.sys_tid{  var temp3_id = call(eq, x_64, 4);
  sys_assert_var = temp3_id;
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  } -> Skip;
  Skip; 
  sys_thread_finalize(sys_tid);

var main_sys_tid = sys_tid_allocator.allocate();
main = main_init{  // initialize runable
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (main_sys_tid, __temp_list_args);
  sys_runable_list = __temp_list_args;
  sys_runable_size = 1;
  sys_cur_tid = main_sys_tid;

  sys_new_tid = -1;  // -1: not creating new thread
  } -> (sys_main(main_sys_tid) ||| sys_scheduler_random);

#define sys_assertion sys_assert_var == true;

// #assert main deadlockfree;

// #assert main |= G sys_assertion;


#assert main deadlockfree;

#assert main |= G sys_assertion;



