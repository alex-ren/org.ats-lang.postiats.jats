// ===============================

#import "MyLib";  // import the library

// =====================

// library data structure (e.g. tuple, list)
var<MyLibObj> sys_mylib_obj = new MyLibObj();

// Set the initial capacity to 10.
var<AtomRefManager> atom_ref_manager = new AtomRefManager(10);

// Set the initial capacity to 10.
var<ArrayRefManager> array_ref_manager = new ArrayRefManager(10);

//
var<ViewManager> view_manager = new ViewManager();

// ====================
// For scheduler

// id of currrent running thread
var sys_cur_tid = 0;

// list of runable threads
var sys_runable_list;
var sys_runable_size;

sys_runable_run_random(xs, n) = 
  ifa (n == 0) {sys_end -> Skip}
  else ifa (n == 1) {
    sys_run_first_one(xs)
  }
  else {
    sys_run_first_one(xs)
    <>
    sys_runable_run_random(sys_mylib_obj.list_get_tail(xs), n - 1)
  };

var sys_show_cur_tid;

sys_run_first_one(xs) = get_cur_tid{sys_show_cur_tid = sys_mylib_obj.list_get_header(xs);} ->
  sys_run_first_one_scheduleto.sys_show_cur_tid{sys_cur_tid = sys_mylib_obj.list_get_header(xs);
  } -> 
  sys_scheduler_random
  ;

var sys_new_tid;  // indicator for creating new thread
var sys_new_fn;
var sys_new_args;

sys_scheduler_random = [sys_cur_tid == -1](
  ifa (sys_new_tid == -1) {  // schedule
    sys_runable_run_random(sys_runable_list, sys_runable_size)
  } else {  // create new thread
    sys_sch_thread_starter(sys_new_tid, sys_new_fn, sys_new_args)
  });


sys_sch_thread_starter(tid, fn, args) = sys_sch_thread_starter_s1.tid{
    sys_new_tid = -1;
    sys_runable_list =  sys_mylib_obj.list_insert_ordered(tid, sys_runable_list);
    sys_runable_size = sys_runable_size + 1;

    // Create a list with one element for stack
    var __temp_list_args = sys_mylib_obj.list_nil ();
    __temp_list_args = sys_mylib_obj.list_cons (args, __temp_list_args);
    sys_gstack.add_frame(tid, __temp_list_args);

  } -> 
  ifa (fn == 9) {
      ([sys_cur_tid == tid]loop_writer_110(tid);sys_thread_finalize(tid)) ||| sys_scheduler_random
    }
    else ifa (fn == 10) {
      ([sys_cur_tid == tid]loop_reader_112(tid);sys_thread_finalize(tid)) ||| sys_scheduler_random
    }
    else {
      Stop
    };
  // sys_sch_thread_starter

sys_thread_finalize(sys_tid) = [sys_cur_tid == sys_tid] sys_thread_finalize_s1.sys_tid{
    // finalize thread
    // remove tid
    sys_runable_list = sys_mylib_obj.list_remove_element(sys_runable_list, sys_tid);
    sys_runable_size = sys_runable_size - 1;
    sys_cur_tid = -1;  // schedule out
  } -> Skip;

sys_thread_create(sys_tid, tid, fn, args) = [sys_cur_tid == sys_tid] sys_thread_create_s1.sys_tid{
    sys_new_tid = tid;
    sys_new_fn = fn;
    sys_new_args = args;

    sys_cur_tid = -1;
  } -> Skip;

// =====================
// For global exclusion.
var sys_glb = 0;

// =====================

// Stack Operation
var<PStack> sys_gstack = new PStack();

// thread id allocator
var<Allocator> sys_tid_allocator = new Allocator();  // todo: improve

// =====================

// Set the initial capacity to 10.
#define MUTEX_NO  10;
var<Allocator> sys_mutex_manager = new Allocator();

// ====================

var sys_mutex_repo = [-1(MUTEX_NO)];
var<AtomRefManager> sys_mutex_waiting_list_manager = new AtomRefManager(MUTEX_NO);

sys_init_mutex_service(n) = sys_init_mutex_service_s1{
  sys_mutex_waiting_list_manager.initialize(n, sys_mylib_obj.list_nil());
} -> Skip;

sys_mutex_acquire(sys_tid, m) = 
  ifa (sys_mutex_repo[m] == -1) {  // can have the mutex
    sys_mutex_acquire_yes.sys_tid{sys_mutex_repo[m] = sys_tid;} -> Skip
  } else {
   sys_mutex_acquire_no.sys_tid{  // cannot have the mutex
      // remove current thread from runable
      sys_runable_list = sys_mylib_obj.list_remove_element(sys_runable_list, sys_tid);
      sys_runable_size = sys_runable_size - 1;

      // add current thread to waiting list
      var __temp_list_args = 
        sys_mylib_obj.list_insert_ordered(sys_tid, sys_mutex_waiting_list_manager.getElement(m));
      sys_mutex_waiting_list_manager.setElement(m, __temp_list_args);

      sys_cur_tid = -1;  // schedule out
    } -> Skip
  }
  ;

sys_mutex_release(sys_tid, m) = 
  ifa(sys_mylib_obj.list_is_nil(sys_mutex_waiting_list_manager.getElement(m))) {
    sys_mutex_release_s1.sys_tid{
      sys_mutex_repo[m] = -1;
      sys_cur_tid = -1;  // schedule out
    } -> Skip
  } else {
    sys_mutex_release_random(sys_tid, m, sys_mutex_waiting_list_manager.getElement(m))
  }

sys_mutex_release_random(sys_tid, m, waiting_list) = 
  ifa (sys_mylib_obj.list_is_nil(sys_mylib_obj.list_get_tail(waiting_list))) {
    sys_mutex_release_random_first(sys_tid, m, sys_mylib_obj.list_get_header(waiting_list))
  } else {
    sys_mutex_release_random_first(sys_tid, m, sys_mylib_obj.list_get_header(waiting_list))
    <>
    sys_mutex_release_random(sys_tid, m, sys_mylib_obj.list_get_tail(waiting_list))
  }
  ;

sys_mutex_release_random_first(sys_tid, m, tid) = {
  // remove from waiting list
  var waiting_list = sys_mutex_waiting_list_manager.getElement(m);
  var new_list = sys_mylib_obj.list_remove_element(waiting_list, tid);
  sys_mutex_waiting_list_manager.setElement(m, new_list);

  sys_mutex_repo[m] = tid;

  // add to runable
  sys_runable_list = sys_mylib_obj.list_insert_ordered(tid, sys_runable_list);
  sys_runable_size = sys_runable_size + 1;

  sys_cur_tid = -1;  // schedule out
  } -> Skip;

// ====================

conats_mutex_acquire(sys_tid) = 
  [sys_cur_tid == sys_tid] 
  sys_mutex_acquire(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));

conats_mutex_release(sys_tid) = 
  [sys_cur_tid == sys_tid] 
  sys_mutex_release (sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));

// =================================
// Set the initial capacity to 10.
#define COND_NO  10;
var<Allocator> sys_cond_manager = new Allocator();

// ======================

var sys_cond_repo = [0(COND_NO)];
var<AtomRefManager> sys_cond_sleep_list_manager = new AtomRefManager(COND_NO);

// ======================

sys_init_cond_service(n) = sys_init_cond_service_s1{
  sys_cond_sleep_list_manager.initialize(n, sys_mylib_obj.list_nil());
} -> Skip;


sys_cond_signal(sys_tid, c, m) = 
  ifa(sys_mylib_obj.list_is_nil(sys_cond_sleep_list_manager.getElement(c))) {
    sys_cond_signal_empty.sys_tid -> Skip
  } else {
    sys_cond_signal_random(sys_tid, c, sys_cond_sleep_list_manager.getElement(c))
  }

sys_cond_signal_random(sys_tid, c, sleep_list) = 
  ifa (sys_mylib_obj.list_is_nil(sys_mylib_obj.list_get_tail(sleep_list))) {
    sys_cond_signal_random_first(sys_tid, c, sys_mylib_obj.list_get_header(sleep_list))
  } else {
    sys_cond_signal_random_first(sys_tid, c, sys_mylib_obj.list_get_header(sleep_list))
    <>
    sys_cond_signal_random(sys_tid, c, sys_mylib_obj.list_get_tail(sleep_list))
  }
  ;

sys_cond_signal_random_first(sys_tid, c, tid) = sys_cond_signal_random_first_s1.sys_tid{
  // remove from sleep list
  var sleep_list = sys_cond_sleep_list_manager.getElement(c);
  var new_list = sys_mylib_obj.list_remove_element(sleep_list, tid);
  sys_cond_sleep_list_manager.setElement(c, new_list);

  // add to runable
  sys_runable_list = sys_mylib_obj.list_insert_ordered(tid, sys_runable_list);
  sys_runable_size = sys_runable_size + 1;
  } -> Skip;

sys_cond_wait(sys_tid, c, m) = sys_cond_wait_s1.sys_tid{
  // remove from runable
  sys_runable_list = sys_mylib_obj.list_remove_element(sys_runable_list, sys_tid);
  sys_runable_size = sys_runable_size - 1;
  // add to sleep
  var new_list = sys_mylib_obj.list_insert_ordered(sys_tid, sys_cond_sleep_list_manager.getElement(c));
  sys_cond_sleep_list_manager.setElement(c, new_list);
  } -> Skip;
  // release mutex. This would cause schedule out
  sys_mutex_release(sys_tid, m);
  [sys_cur_tid == sys_tid]  // schedule in
  sys_mutex_acquire(sys_tid, m);

sys_cond_broadcast(sys_tid, c) = sys_cond_broadcast_s1{
  var sleep_list = sys_cond_sleep_list_manager.getElement(c);
  sys_runable_list = sys_mylib_obj.list_merge_ordered(sys_runable_list, sleep_list);
  sys_runable_size = sys_runable_size + sys_mylib_obj.list_length(sleep_list);
  sys_cond_sleep_list_manager.setElement(c, sys_mylib_obj.list_nil());
  } -> Skip;

// ======================

conats_shared_acquire(sys_tid) = 
  [sys_cur_tid == sys_tid]
  conats_shared_acquire_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));

//  tup = sys_gstack.frame_get(sys_tid, 0, 0)
//  a = sys_mylib_obj.getTupleElement(tup, 0);
//  mutex = sys_mylib_obj.getTupleElement(tup, 1);
//  cond = sys_mylib_obj.getTupleElement(tup, 2);
conats_shared_acquire_impl(sys_tid, tup) =
    conats_shared_acquire_impl_s1.sys_tid{
      sys_gstack.frame_push(sys_tid, sys_mylib_obj.getTupleElement(tup, 0))  // return a
    } ->
    sys_mutex_acquire(sys_tid, sys_mylib_obj.getTupleElement(tup, 1))
    ;

// ====================

conats_shared_release(sys_tid) = 
  [sys_cur_tid == sys_tid] 
  conats_shared_release_impl(sys_tid, 
                             sys_gstack.frame_get(sys_tid, 0, 0),
                             sys_gstack.frame_get(sys_tid, 0, 1)
                            );

conats_shared_release_impl(sys_tid, tup, a) = 
  sys_mutex_release(sys_tid, sys_mylib_obj.getTupleElement(tup, 1));

// ====================

conats_shared_signal(sys_tid) = 
  [sys_cur_tid == sys_tid]
  conats_shared_signal_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), 0);


conats_sharedn_signal(sys_tid) = 
  [sys_cur_tid == sys_tid]
  conats_shared_signal_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), 
                                            sys_gstack.frame_get(sys_tid, 0, 1));

conats_shared_signal_impl(sys_tid, tup, index) = sys_cond_signal(sys_tid, 
                                  sys_mylib_obj.getTupleElement(tup, index + 2),  // cond
                                  sys_mylib_obj.getTupleElement(tup, 1));  // mutex

// ====================

conats_shared_condwait(sys_tid) = 
  [sys_cur_tid == sys_tid]
  conats_shared_condwait_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), 0);

conats_sharedn_condwait(sys_tid) = 
  [sys_cur_tid == sys_tid]
  conats_shared_condwait_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), 
                                              sys_gstack.frame_get(sys_tid, 0, 1));

conats_shared_condwait_impl(sys_tid, tup, index) = sys_cond_wait(sys_tid, 
                                  sys_mylib_obj.getTupleElement(tup, index + 2),  // cond
                                  sys_mylib_obj.getTupleElement(tup, 1));  // mutex

// ====================

conats_shared_broadcast(sys_tid) = 
  [sys_cur_tid == sys_tid]
  conats_shared_broadcast_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), 0);

conats_sharedn_broadcast(sys_tid) = 
  [sys_cur_tid == sys_tid]
  conats_shared_broadcast_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), 
                                               sys_gstack.frame_get(sys_tid, 0, 1));

conats_shared_broadcast_impl(sys_tid, tup, index) = 
    sys_cond_broadcast(sys_tid, sys_mylib_obj.getTupleElement(tup, index + 2));

// ===============================
// global variable for assertion
var sys_assert_var = true;

// =====================

var data_94 = 0;
var slot_95 = 0;
var latest_96 = 0;
var reading_97 = 0;
var tid1_114 = 0;
var tid2_115 = 0;

loop_69(sys_tid) =
  [sys_cur_tid == sys_tid] loop_69_s1.sys_tid{  var temp4_id = call(gte, sys_gstack.frame_get(sys_tid, 0, 0), 0);
  sys_gstack.frame_push(sys_tid, temp4_id);
  } -> Skip;
  ifa (sys_gstack.frame_get_bool(sys_tid, 0, 4)) {
    [sys_cur_tid == sys_tid] loop_69_s2.sys_tid{  var ele_74 = array_ref_manager.allocate(sys_gstack.frame_get(sys_tid, 0, 1), sys_gstack.frame_get(sys_tid, 0, 3));

    array_ref_manager.setElement(sys_gstack.frame_get(sys_tid, 0, 2), sys_gstack.frame_get(sys_tid, 0, 0), ele_74);
    if (sys_glb == 0) {  // not atomic
      sys_cur_tid = -1;
    }
    } -> Skip;
    [sys_cur_tid == sys_tid] loop_69_s3.sys_tid{  var temp6_id = call(sub, sys_gstack.frame_get(sys_tid, 0, 0), 1);
    var __temp_list_args = sys_mylib_obj.list_nil ();
    __temp_list_args = sys_mylib_obj.list_cons (temp6_id, __temp_list_args);
    __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 1), __temp_list_args);
    __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 2), __temp_list_args);
    __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 3), __temp_list_args);
    sys_gstack.reload_frame(sys_tid, __temp_list_args);
    } -> Skip;
    loop_69(sys_tid)
  } else {
    Skip
  }
  ;

dataslots_create_63(sys_tid) =
  [sys_cur_tid == sys_tid] dataslots_create_63_s1.sys_tid{  var ele_67 = array_ref_manager.allocate(sys_gstack.frame_get(sys_tid, 0, 1), sys_gstack.frame_get(sys_tid, 0, 2));

  var array_68 = array_ref_manager.allocate(sys_gstack.frame_get(sys_tid, 0, 0), ele_67);

  sys_gstack.frame_push(sys_tid, array_68);
  var temp7_id = call(sub, sys_gstack.frame_get(sys_tid, 0, 0), 2);
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (temp7_id, __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 1), __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (array_68, __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 2), __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } -> Skip;
  loop_69(sys_tid);
  [sys_cur_tid == sys_tid] dataslots_create_63_s2.sys_tid{  sys_gstack.delete_frame(sys_tid);
  sys_gstack.frame_push(sys_tid, sys_gstack.frame_get(sys_tid, 0, 3));
  } -> Skip;
  Skip
  ;

dataslots_update_75(sys_tid) =
  [sys_cur_tid == sys_tid] dataslots_update_75_s1.sys_tid{  var ele_81 = array_ref_manager.getElement(sys_gstack.frame_get(sys_tid, 0, 1), sys_gstack.frame_get(sys_tid, 0, 2));
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  sys_gstack.frame_push(sys_tid, ele_81);
  } -> Skip;
  [sys_cur_tid == sys_tid] dataslots_update_75_s2.sys_tid{  array_ref_manager.setElement(sys_gstack.frame_get(sys_tid, 0, 5), sys_gstack.frame_get(sys_tid, 0, 3), sys_gstack.frame_get(sys_tid, 0, 4));
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  } -> Skip;
  [sys_cur_tid == sys_tid] dataslots_update_75_s3.sys_tid{  sys_gstack.frame_push(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));
  } -> Skip;
  Skip
  ;

dataslots_get_82(sys_tid) =
  [sys_cur_tid == sys_tid] dataslots_get_82_s1.sys_tid{  var ele_87 = array_ref_manager.getElement(sys_gstack.frame_get(sys_tid, 0, 1), sys_gstack.frame_get(sys_tid, 0, 2));
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  sys_gstack.frame_push(sys_tid, ele_87);
  } -> Skip;
  [sys_cur_tid == sys_tid] dataslots_get_82_s2.sys_tid{  var v_88 = array_ref_manager.getElement(sys_gstack.frame_get(sys_tid, 0, 4), sys_gstack.frame_get(sys_tid, 0, 3));
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  sys_gstack.frame_push(sys_tid, v_88);
  } -> Skip;
  [sys_cur_tid == sys_tid] dataslots_get_82_s3.sys_tid{  var ret11_id = sys_mylib_obj.createTuple(2);
  sys_mylib_obj.setTupleElement(ret11_id, 0, sys_gstack.frame_get(sys_tid, 0, 0));
  sys_mylib_obj.setTupleElement(ret11_id, 1, sys_gstack.frame_get(sys_tid, 0, 5));
  sys_gstack.frame_push(sys_tid, ret11_id);
  } -> Skip;
  Skip
  ;

mc_acquire_ownership_89(sys_tid) =
  [sys_cur_tid == sys_tid] mc_acquire_ownership_89_s1.sys_tid{  var ret12_id = view_manager.get(sys_gstack.frame_get(sys_tid, 0, 0), sys_gstack.frame_get(sys_tid, 0, 1), 1, 1);
  sys_assert_var = !sys_mylib_obj.is_none(ret12_id);
  sys_gstack.frame_push(sys_tid, ret12_id);
  } -> Skip;
  Skip
  ;

mc_release_ownership_92(sys_tid) =
  [sys_cur_tid == sys_tid] mc_release_ownership_92_s1.sys_tid{  view_manager.put(sys_gstack.frame_get(sys_tid, 0, 0));
  } -> Skip;
  Skip
  ;

write_98(sys_tid) =
  [sys_cur_tid == sys_tid] write_98_s1.sys_tid{  var temp15_id = atom_ref_manager.getElement(reading_97);
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  sys_gstack.frame_push(sys_tid, temp15_id);
  } -> Skip;
  [sys_cur_tid == sys_tid] write_98_s2.sys_tid{  var pair_100 = call(sub, 1, sys_gstack.frame_get(sys_tid, 0, 1));
  sys_gstack.frame_push(sys_tid, pair_100);
  var temp16_id = array_ref_manager.getElement(slot_95, pair_100);
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  sys_gstack.frame_push(sys_tid, temp16_id);
  } -> Skip;
  [sys_cur_tid == sys_tid] write_98_s3.sys_tid{  var index_101 = call(sub, 1, sys_gstack.frame_get(sys_tid, 0, 3));
  sys_gstack.frame_push(sys_tid, index_101);
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 2), __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (index_101, __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } -> Skip;
  mc_acquire_ownership_89(sys_tid);
  [sys_cur_tid == sys_tid] write_98_s4.sys_tid{  var vpf_102 = sys_gstack.retopr_frame(sys_tid);
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (vpf_102, __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (data_94, __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 2), __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 4), __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 0), __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } -> Skip;
  dataslots_update_75(sys_tid);
  [sys_cur_tid == sys_tid] write_98_s5.sys_tid{  var vpf_103 = sys_gstack.retopr_frame(sys_tid);
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (vpf_103, __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } -> Skip;
  mc_release_ownership_92(sys_tid);
  [sys_cur_tid == sys_tid] write_98_s6.sys_tid{  sys_gstack.delete_frame(sys_tid);
  array_ref_manager.setElement(slot_95, sys_gstack.frame_get(sys_tid, 0, 2), sys_gstack.frame_get(sys_tid, 0, 4));
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  } -> Skip;
  [sys_cur_tid == sys_tid] write_98_s7.sys_tid{  atom_ref_manager.setElement(latest_96, sys_gstack.frame_get(sys_tid, 0, 2));
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  } -> Skip;
  Skip
  ;

read_104(sys_tid) =
  [sys_cur_tid == sys_tid] read_104_s1.sys_tid{  var pair_105 = atom_ref_manager.getElement(latest_96);
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  sys_gstack.frame_push(sys_tid, pair_105);
  } -> Skip;
  [sys_cur_tid == sys_tid] read_104_s2.sys_tid{  atom_ref_manager.setElement(reading_97, sys_gstack.frame_get(sys_tid, 0, 0));
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  } -> Skip;
  [sys_cur_tid == sys_tid] read_104_s3.sys_tid{  var index_106 = array_ref_manager.getElement(slot_95, sys_gstack.frame_get(sys_tid, 0, 0));
  if (sys_glb == 0) {  // not atomic
    sys_cur_tid = -1;
  }
  sys_gstack.frame_push(sys_tid, index_106);
  } -> Skip;
  [sys_cur_tid == sys_tid] read_104_s4.sys_tid{  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 0), __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 1), __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } -> Skip;
  mc_acquire_ownership_89(sys_tid);
  [sys_cur_tid == sys_tid] read_104_s5.sys_tid{  var vpf_107 = sys_gstack.retopr_frame(sys_tid);
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (vpf_107, __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (data_94, __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 0), __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 1), __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } -> Skip;
  dataslots_get_82(sys_tid);
  [sys_cur_tid == sys_tid] read_104_s6.sys_tid{  var temp22_id = sys_gstack.retopr_frame(sys_tid);
  var vpf_108 = sys_mylib_obj.getTupleElement(temp22_id, 0);
  var item_109 = sys_mylib_obj.getTupleElement(temp22_id, 1);
  sys_gstack.frame_push(sys_tid, item_109);
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (vpf_108, __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } -> Skip;
  mc_release_ownership_92(sys_tid);
  [sys_cur_tid == sys_tid] read_104_s7.sys_tid{  sys_gstack.delete_frame(sys_tid);
  sys_gstack.frame_push(sys_tid, sys_gstack.frame_get(sys_tid, 0, 2));
  } -> Skip;
  Skip
  ;

loop_writer_110(sys_tid) =
  [sys_cur_tid == sys_tid] loop_writer_110_s1.sys_tid{  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 0), __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } -> Skip;
  write_98(sys_tid);
  [sys_cur_tid == sys_tid] loop_writer_110_s2.sys_tid{  sys_gstack.delete_frame(sys_tid);
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 0), __temp_list_args);
  sys_gstack.reload_frame(sys_tid, __temp_list_args);
  } -> Skip;
  loop_writer_110(sys_tid)
  ;

loop_reader_112(sys_tid) =
  [sys_cur_tid == sys_tid] loop_reader_112_s1.sys_tid{  var __temp_list_args = sys_mylib_obj.list_nil ();
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } -> Skip;
  read_104(sys_tid);
  [sys_cur_tid == sys_tid] loop_reader_112_s2.sys_tid{  var temp27_id = sys_gstack.retopr_frame(sys_tid);
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 0), __temp_list_args);
  sys_gstack.reload_frame(sys_tid, __temp_list_args);
  } -> Skip;
  loop_reader_112(sys_tid)
  ;

// =====================

sys_main(sys_tid) = [sys_cur_tid == sys_tid]
  sys_main_init.sys_tid{var __temp_list_args = sys_mylib_obj.list_nil ();
            sys_gstack.add_frame(0, __temp_list_args); 
            } -> Skip;
  [sys_cur_tid == sys_tid] main41_id_s1.sys_tid{  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (2, __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (2, __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (0, __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } -> Skip;
  dataslots_create_63(sys_tid);
  [sys_cur_tid == sys_tid] main41_id_s2.sys_tid{  data_94 = sys_gstack.retopr_frame(sys_tid);
  slot_95 = array_ref_manager.allocate(2, 0);

  latest_96 = atom_ref_manager.allocate(0);

  reading_97 = atom_ref_manager.allocate(0);

  tid1_114 = sys_tid_allocator.allocate();

  tid2_115 = sys_tid_allocator.allocate();

  } -> Skip;
  sys_thread_create(sys_tid, tid1_114, 10, 0);
  sys_thread_create(sys_tid, tid2_115, 9, 0); 
  sys_thread_finalize(sys_tid);

var main_sys_tid = sys_tid_allocator.allocate();
main = 
  sys_init_mutex_service(MUTEX_NO);
  sys_init_cond_service(COND_NO);
  main_init_scheduler {  // initialize runable
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_insert_ordered(main_sys_tid, __temp_list_args);
  sys_runable_list = __temp_list_args;
  sys_runable_size = 1;
  sys_cur_tid = main_sys_tid;

  sys_new_tid = -1;  // -1: not creating new thread
  } -> (sys_main(main_sys_tid) ||| sys_scheduler_random);

#define sys_assertion sys_assert_var == true;

// #assert main deadlockfree;

// #assert main |= G sys_assertion;


#assert main deadlockfree;

#assert main |= G sys_assertion;



