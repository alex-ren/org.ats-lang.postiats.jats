// ===============================

#import "MyLib";  // import the library

// =====================

// library data structure (e.g. tuple, list)
var<MyLibObj> sys_mylib_obj = new MyLibObj();

// Set the initial capacity to 10.
var<AtomRefManager> atom_ref_manager = new AtomRefManager(10);

// Set the initial capacity to 10.
var<ArrayRefManager> array_ref_manager = new ArrayRefManager(10);

//
var<ViewManager> view_manager = new ViewManager();

// =====================
// For global exclusion.
var glb = 0;

// =====================

// Stack Operation
var<PStack> sys_gstack = new PStack();

// thread id allocator
var<Allocator> sys_tid_allocator = new Allocator();  // todo: improve

// =====================

var sys_thread_num = 1;

channel sys_ch_sch 0;

var sch_sys_tid;
var sch_fn;
var sch_args;

sch_thread_starter(sys_tid, fn, args) =
thread_init{
  // Create a list with one element.
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (args, __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
} ->
  Skip
;

Scheduler() = (atomic{sys_ch_sch?sys_tid.fn.args ->  // It's safe to use *atomic* here.
                      {sys_thread_num++;
                       sch_sys_tid = sys_tid;
                       sch_fn = fn;
                       sch_args = args;
                      } -> Skip
                      };
  sch_thread_starter(sch_sys_tid, sch_fn, sch_args)
  )
  []
  ifa (sys_thread_num == 0) {Skip}
  ;

proc_thread_finalize(sys_tid) = 
  thread_finalize.sys_tid{
    sys_gstack.delete_frame(sys_tid); 
    sys_thread_num--;
    sys_tid_allocator.release(sys_tid);
  } -> Skip;

sys_thread_create (tid, fn, args) = sys_ch_sch!tid.fn.args -> Skip;

// =====================

var mutex[10];  // 10 mutex

var<Allocator> sys_mutex_manager = new Allocator();

// ====================
conats_mutex_acquire(sys_tid) = sys_mutex_lock_impl (sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));

sys_mutex_lock_impl(sys_tid, m) = [mutex[m] == 0] mlock.sys_tid{mutex[m] = 1} -> Skip;
// ====================
conats_mutex_release(sys_tid) = sys_mutex_unlock_impl (sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));

sys_mutex_unlock_impl(sys_tid, m) = sys_munlock.sys_tid{mutex[m] = 0} -> Skip;
// ======================

var cond_holder[10];  // 10 condition

var<Allocator> sys_cond_manager = new Allocator();

channel cond_chan[10] 0;
var cond_count = 0;

// ====================

conats_shared_acquire(sys_tid) = conats_shared_acquire_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));
//  tup = sys_gstack.frame_get(sys_tid, 0, 0)
//  a = sys_mylib_obj.getTupleElement(tup, 0);
//  mutex = sys_mylib_obj.getTupleElement(tup, 1);
//  cond = sys_mylib_obj.getTupleElement(tup, 2);
conats_shared_acquire_impl(sys_tid, tup) = // atomic{ // Cannot use atomic here. Otherwise it would cause higher priority.
    shared_acq.sys_tid{sys_gstack.frame_push(sys_tid, sys_mylib_obj.getTupleElement(tup, 0))} ->
    sys_mutex_lock_impl(sys_tid, sys_mylib_obj.getTupleElement(tup, 1))
    // }  // end of atomic
    ;
// ====================
conats_shared_release(sys_tid) = conats_shared_release_impl(sys_tid, 
                                          sys_gstack.frame_get(sys_tid, 0, 0),
                                          sys_gstack.frame_get(sys_tid, 0, 1)
                                          );

conats_shared_release_impl(sys_tid, tup, a) = 
    sys_mutex_unlock_impl(sys_tid, sys_mylib_obj.getTupleElement(tup, 1));
// ====================
conats_shared_signal(sys_tid) = conats_shared_signal_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), 0);
conats_sharedn_signal(sys_tid) = conats_shared_signal_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), sys_gstack.frame_get(sys_tid, 0, 1));

conats_shared_signal_impl(sys_tid, tup, index) = 
    sys_cond_signal_impl(sys_tid, sys_mylib_obj.getTupleElement(tup, index + 2));

sys_cond_signal_impl(sys_tid, c) = atomic {if (cond_holder[c] > 0) {  // I think it's safe to keep *atomic* here.

          csub.sys_tid{cond_holder[c]--;} ->

          cond_chan[c]!1

          -> Skip

        }};    
// ====================

conats_shared_condwait(sys_tid) = 
    conats_shared_condwait_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), 0);

conats_sharedn_condwait(sys_tid) = 
    conats_shared_condwait_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), sys_gstack.frame_get(sys_tid, 0, 1));

conats_shared_condwait_impl(sys_tid, tup, index) = sys_cond_wait_impl(sys_tid, 
                                  sys_mylib_obj.getTupleElement(tup, index + 2),  // cond
                                  sys_mylib_obj.getTupleElement(tup, 1));  // mutex

sys_cond_wait_impl(sys_tid, c, m) = atomic{
  cadd.sys_tid{cond_holder[c]++;} -> 
  sys_mutex_unlock_impl(sys_tid, m); 
  cond_chan[c]?_ -> Skip }; 
  sys_mutex_lock_impl(sys_tid, m)  // Cannot use atomic here. Otherwise it would cause current thread has higher priority to lock.
  ;

// ====================

conats_shared_broadcast(sys_tid) = conats_shared_broadcast_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), 0);
conats_sharedn_broadcast(sys_tid) = conats_shared_broadcast_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), sys_gstack.frame_get(sys_tid, 0, 1));


conats_shared_broadcast_impl(sys_tid, tup, index) = 
    sys_cond_broadcast_impl(sys_tid, sys_mylib_obj.getTupleElement(tup, index + 2));

sys_cond_broadcast_impl(sys_tid, c) = atomic{if (cond_holder[c] > 0) {  // It's safe to use *atomic* here.

          sys_signaln(c, cond_holder[c]); csub{cond_holder[c]=0;} -> Skip

        }};

sys_signaln(c, n) = if (n > 0) {cond_chan[c]!1 -> sys_signaln(c, n-1)}
                else {Skip}
                ;

// ===============================

// #define sys_list_nil  sys_list_manager.list_nil ();
// #define sys_list_cons(x, xs) sys_list_manager.list_cons (x, xs);
// #define sys_list_get_header(xs) sys_list_manager.list_get_header (xs);
// #define sys_list_get_tail(xs) sys_list_manager.list_get_tail (xs);
// #define sys_list_is_nil(xs) sys_list_manager.list_is_nil (xs);

// ===============================
// global variable for assertion
var sys_assert_var = true;

// =====================


foo2_63(sys_tid) =
  foo2_63_s1.sys_tid{  sys_gstack.frame_push(sys_tid, sys_gstack.frame_get(sys_tid, 0, 1));
  } ->
  Skip
  ;

foo_66(sys_tid) =
  foo_66_s1.sys_tid{  var x_68 = sys_mylib_obj.list_is_nil(sys_gstack.frame_get(sys_tid, 0, 0));
  var y_69 = sys_mylib_obj.list_get_header(sys_gstack.frame_get(sys_tid, 0, 0));
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (2, __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (3, __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } ->
  foo2_63(sys_tid);
  foo_66_s2.sys_tid{  var x_70 = sys_gstack.retopr_frame(sys_tid);
  } ->
  Skip
  ;

// =====================

main_s(sys_tid) = 
  main_init.sys_tid{var __temp_list_args = sys_mylib_obj.list_nil ();
            sys_gstack.add_frame(0, __temp_list_args); 
            } ->
  Skip; 
  proc_thread_finalize(sys_tid);

main = main_s(sys_tid_allocator.allocate()) ||| Scheduler;

#define sys_assertion sys_assert_var == true;

// #assert main deadlockfree;

// #assert main |= G sys_assertion;


// =================================
// Set the initial capacity to 10.
#define COND_NO  10;
var cond2 = [0(COND_NO)];
var<AtomRefManager> cond_sleep_list_manager = new AtomRefManager(COND_NO);

InitCond2(n) = InitCond_s1{
  cond_sleep_list_manager.initialize(n, sys_mylib_obj.list_nil());
} -> Skip;


CondSignal(sys_tid, c) = 
  ifa(sys_mylib_obj.list_is_nil(cond_sleep_list_manager.getElement(c))) {
    Skip
  } else {
    CondSignalRandom(sys_tid, c, cond_sleep_list_manager.getElement(c))
  }

CondSignalRandom(sys_tid, c, sleep_list) = 
  ifa (sys_mylib_obj.list_is_nil(sys_mylib_obj.list_get_tail(sleep_list))) {
    CondSignalRandom_first(sys_tid, c, sys_mylib_obj.list_get_header(sleep_list))
  } else {
    CondSignalRandom_first(sys_tid, c, sys_mylib_obj.list_get_header(sleep_list))
    <>
    CondSignalRandom(sys_tid, c, sys_mylib_obj.list_get_tail(sleep_list))
  }
  ;
  
CondSignalRandom_first(sys_tid, c, tid) = {
  // remove from sleep list
  var sleep_list = cond_sleep_list_manager.getElement(c);
  var new_list = sys_mylib_obj.list_remove_element(sleep_list, tid);
  cond_sleep_list_manager.setElement(c, new_list);
  
  // add to runable
  runable = sys_mylib_obj.list_cons(tid, runable);
  runable_size = runable_size + 1;
  } -> Skip;


CondBroadcast(sys_tid, c) = CondBroadcast_s1{
  runable = sys_mylib_obj.list_revappend(runable, cond_sleep_list_manager.getElement(c));
  cond_sleep_list_manager.setElement(c, sys_mylib_obj.list_nil());
  } -> Skip;

CondWait(sys_tid, c, m) = {
  // remove from runable
  runable = sys_mylib_obj.list_remove_element(runable, sys_tid);
  // add to sleep
  var new_list = sys_mylib_obj.list_cons(sys_tid, cond_sleep_list_manager.getElement(c));
  cond_sleep_list_manager.setElement(c, new_list);
  } -> Skip;
  // release mutex. This would cause schedule out
  MutexRelease(sys_tid, m);
  MutexAcquire(sys_tid, m);



// =================================

// Set the initial capacity to 10.
#define MUTEX_NO  10;
var mutex2 = [-1(MUTEX_NO)];
var<AtomRefManager> mutex_waiting_list_manager = new AtomRefManager(MUTEX_NO);

InitMutex2(n) = InitMutex_s1{
  mutex_waiting_list_manager.initialize(n, sys_mylib_obj.list_nil());
} -> Skip;

MutexAcquire(sys_tid, m) =
  ifa (mutex2[m] == -1) {  // can have the mutex
    MutexAcquire_yes.sys_tid{mutex2[m] = sys_tid;} -> Skip
  } else {
    MutexAcquire_no.sys_tid{  // cannot have the mutex
      // remove current thread from runable
      runable = sys_mylib_obj.list_remove_element(runable, sys_tid);
      runable_size = runable_size - 1;
      
      // add current thread to waiting list
      var new_list = sys_mylib_obj.list_cons(sys_tid, mutex_waiting_list_manager.getElement(m));
      mutex_waiting_list_manager.setElement(m, new_list);
      
      cur_tid = -1;  // schedule out
    } -> ([cur_tid == sys_tid] Skip)  // schedule in
  }
  ;

MutexRelease(sys_tid, m) = 
  ifa(sys_mylib_obj.list_is_nil(mutex_waiting_list_manager.getElement(m))) {
    MutexRelease_s1.sys_tid{
      mutex2[m] = -1;
      cur_tid = -1;  // schedule out
    } -> ([sys_tid == cur_tid] Skip)  // schedule in
  } else {
    MutexReleaseRandom(sys_tid, m, mutex_waiting_list_manager.getElement(m))
  }

MutexReleaseRandom(sys_tid, m, waiting_list) = 
  ifa (sys_mylib_obj.list_is_nil(sys_mylib_obj.list_get_tail(waiting_list))) {
    MutexReleaseRandom_first(sys_tid, m, sys_mylib_obj.list_get_header(waiting_list))
  } else {
    MutexReleaseRandom_first(sys_tid, m, sys_mylib_obj.list_get_header(waiting_list))
    <>
    MutexReleaseRandom(sys_tid, m, sys_mylib_obj.list_get_tail(waiting_list))
  }
  ;
  
MutexReleaseRandom_first(sys_tid, m, tid) = {
  // remove from waiting list
  var waiting_list = mutex_waiting_list_manager.getElement(m);
  var new_list = sys_mylib_obj.list_remove_element(waiting_list, tid);
  mutex_waiting_list_manager.setElement(m, new_list);
  
  mutex2[m] = tid;
  
  // add to runable
  runable = sys_mylib_obj.list_cons(tid, runable);
  runable_size = runable_size + 1;
  
  cur_tid = -1;  // schedule out
  } -> Skip;
  [cur_tid == sys_tid] Skip;  // Schedule in
  
// =================================
// Scheduler

// id of currrent running thread
var cur_tid = 0;

// list of runable threads
var runable;
var runable_size;


runable_get_random(xs, n) = 
  ifa (n == 0) {Skip}
  else ifa (n == 1) {
    run_first_one(xs)
  }
  else {
    run_first_one(xs)
    <>
    runable_get_random(sys_mylib_obj.list_get_tail(xs), n - 1)
  };
  
run_first_one(xs) = 
  run_first_one_s1{cur_tid = sys_mylib_obj.list_get_header(xs);
  } -> 
  scheduler_random
  ;

var new_tid = -1;  // indicator for creating new thread
var new_fn;
var new_args;

scheduler_random = [cur_tid == -1](
  ifa (new_tid == -1) {  // schedule
    runable_get_random(runable, runable_size)
  } else {  // create new thread
    sch_thread_starter2(new_tid, new_fn, new_args)
  });
  
sch_thread_starter2(tid, fn, args) = sch_thread_starter2_s1{
    new_tid = -1;
    runable =  sys_mylib_obj.list_cons(tid, runable);
    runable_size = runable_size + 1;
  } -> ifa (fn == 1) {
    ([cur_tid == tid]P1(tid, args);thread_finalize2(tid)) ||| scheduler_random
  } else ifa (fn == 2) {
    ([cur_tid == tid]P2(tid, args);thread_finalize2(tid)) ||| scheduler_random
  } else ifa (fn == 3) {
    ([cur_tid == tid]P3(tid, args);thread_finalize2(tid)) ||| scheduler_random
  } else ifa (fn == 4) {
    ([cur_tid == tid]P4(tid, args);thread_finalize2(tid)) ||| scheduler_random
  }
  else {
    Stop
  };
  
thread_finalize2(sys_tid) = thread_finalize2_s1.sys_tid{
    // finalize thread
    // remove tid
    runable = sys_mylib_obj.list_remove_element(runable, sys_tid);
    runable_size = runable_size - 1;
    cur_tid = -1;  // schedule out
  } -> Skip;

thread_create(sys_tid, tid, fn, args) = thread_create_s1.sys_tid{
    new_tid = tid;
    new_fn = fn;
    new_args = args;
  
    cur_tid = -1;
  } -> ([cur_tid == sys_tid] Skip);

// ===================================

var gx = 0;

P1(sys_tid, args) = p1_s1.sys_tid{
    gx = 1;
    cur_tid = -1;  // schedule out
  } -> Skip;
  [cur_tid == sys_tid] p1_s2.sys_tid{  // schedule in
    gx = 2;
  } -> 
  MutexAcquire(sys_tid, args);
  MutexRelease(sys_tid, args);
  p1_s3.sys_tid{ var x = 5;
  } -> 
  Skip;
  
P2(sys_tid, args) = p2_s1.sys_tid{
    gx = 3;
    cur_tid = -1;  // schedule out
  } -> Skip;
  [cur_tid == sys_tid] p2_s2.sys_tid{  // schedule in
    gx = 4;
    cur_tid = -1;  // schedule out
  } -> Skip;
  [cur_tid == sys_tid] Skip;// schedule in
  MutexAcquire(sys_tid, args);
  MutexRelease(sys_tid, args);

P3(sys_tid, args) = p3_s1.sys_tid{
    gx = 1;
  } -> Skip;
  MutexAcquire(sys_tid, args);
  CondWait(sys_tid, args, args);
  MutexRelease(sys_tid, args);

P4(sys_tid, args) = p4_s1.sys_tid{
    gx = 2;
  } -> Skip;
  MutexAcquire(sys_tid, args);
  CondSignal(sys_tid, args);
  MutexRelease(sys_tid, args);

Main2 = 
  InitMutex2(MUTEX_NO);  // initialize mutex
  InitCond2(COND_NO);
  main_s1.0{
  var xs = sys_mylib_obj.list_nil ();
  xs = sys_mylib_obj.list_cons (0, xs);
  runable = xs;
  runable_size = 1;
  cur_tid = -1;  // schedule out
  } -> Skip;
  [cur_tid == 0] Skip;  // schedule in
  // sys_tid, tid, fn, args
  // thread_create(0, 1, 1, 0);
  // thread_create(0, 2, 2, 0);
  // thread_create(0, 3, 2, 0);

  thread_create(0, 4, 3, 0);
  thread_create(0, 5, 4, 0);

  thread_finalize2(0);

  
main2 = Main2 ||| scheduler_random;
  
#assert main2 deadlockfree;

// #assert main |= G sys_assertion;




