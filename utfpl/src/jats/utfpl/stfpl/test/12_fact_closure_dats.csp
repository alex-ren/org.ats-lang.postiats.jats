// ===============================

#import "MyLib";  // import the library

// =====================

// library data structure (e.g. tuple, list)
var<MyLibObj> sys_mylib_obj = new MyLibObj();

// Set the initial capacity to 10.
var<AtomRefManager> atom_ref_manager = new AtomRefManager(10);

// Set the initial capacity to 10.
var<ArrayRefManager> array_ref_manager = new ArrayRefManager(10);

// =====================

// Stack Operation
var<PStack> sys_gstack = new PStack();

// thread id allocator
var<Allocator> sys_tid_allocator = new Allocator();  // todo: improve

// =====================

var sys_thread_num = 1;

channel sys_ch_sch 0;

var sch_sys_tid;
var sch_fn;
var sch_args;

sch_thread_starter(sys_tid, fn, args) =
  thread_init{sys_gstack.add_frame(sys_tid, args);} ->
  Skip
;

Scheduler() = (atomic{sys_ch_sch?sys_tid.fn.args -> 
                      {sys_thread_num++;
                       sch_sys_tid = sys_tid;
                       sch_fn = fn;
                       sch_args = args;
                      } -> Skip
                      };
  sch_thread_starter(sch_sys_tid, sch_fn, sch_args)
  )
  []
  ifa (sys_thread_num == 0) {Skip}
  ;

proc_thread_finalize(sys_tid) = 
  thread_finalize{
    sys_gstack.delete_frame(sys_tid); 
    sys_thread_num--;
    sys_tid_allocator.release(sys_tid);
  } -> Skip;

sys_thread_create (tid, fn, args) = sys_ch_sch!tid.fn.args -> Skip;

// =====================

var mutex[10];  // 10 mutex

var<Allocator> sys_mutex_manager = new Allocator();

conats_mutex_acquire(sys_tid) = sys_mutex_lock_impl (sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));

sys_mutex_lock_impl(sys_tid, m) = [mutex[m] == 0] mlock{mutex[m] = 1} -> Skip;

conats_mutex_release(sys_tid) = sys_mutex_unlock_impl (sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));

sys_mutex_unlock_impl(sys_tid, m) = sys_munlock{mutex[m] = 0} -> Skip;
// ======================

var cond_holder[10];  // 10 condition

var<Allocator> sys_cond_manager = new Allocator();

channel cond_chan[10] 0;
var cond_count = 0;

sys_cond_wait(sys_tid) = sys_cond_wait_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0), sys_gstack.frame_get(sys_tid, 0, 1));

sys_cond_wait_impl(sys_tid, c, m) = atomic{cadd{cond_holder[c]++;} -> 
                                    sys_mutex_unlock_impl(sys_tid, m); 
                                    cond_chan[c]?_ -> sys_mutex_lock_impl(sys_tid, m)};

sys_cond_signal(sys_tid) = sys_cond_signal_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));

sys_cond_signal_impl(sys_tid, c) = atomic {if (cond_holder[c] > 0) {

          csub{cond_holder[c]--;} ->

          cond_chan[c]!1

          -> Skip

        }};


sys_cond_broadcast(sys_tid) = sys_cond_broadcast_impl(sys_tid, sys_gstack.frame_get(sys_tid, 0, 0));

sys_cond_broadcast_impl(sys_tid, c) = atomic{if (cond_holder[c] > 0) {

          sys_signaln(c, cond_holder[c]); csub{cond_holder[c]=0;} -> Skip

        }};

sys_signaln(c, n) = if (n > 0) {cond_chan[c]!1 -> sys_signaln(c, n-1)}
                else {Skip}
                ;

// ===============================

// #define sys_list_nil  sys_list_manager.list_nil ();
// #define sys_list_cons(x, xs) sys_list_manager.list_cons (x, xs);
// #define sys_list_get_header(xs) sys_list_manager.list_get_header (xs);
// #define sys_list_get_tail(xs) sys_list_manager.list_get_tail (xs);
// #define sys_list_is_nil(xs) sys_list_manager.list_is_nil (xs);

// ===============================
// global variable for assertion
var sys_assert_var = true;

// =====================


fact1_63(sys_tid) =
  {  var fact1_clo19_id = sys_mylib_obj.createTuple2(1, sys_gstack.frame_get(sys_tid, 0, 1));
  var temp4_id = call(lte, sys_gstack.frame_get(sys_tid, 0, 0), 1);
  sys_gstack.frame_push(sys_tid, temp4_id);
  } ->
  if (sys_gstack.frame_get_bool(sys_tid, 0, 2)) {
    {  sys_gstack.frame_push(sys_tid, 1);
    } ->
    Skip
  } else {
    {  var temp32_id = call(sub, sys_gstack.frame_get(sys_tid, 0, 0), 1);
    var __temp_list_args = sys_mylib_obj.list_nil ();
    __temp_list_args = sys_mylib_obj.list_cons (temp32_id, __temp_list_args);
    __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 1), __temp_list_args);
    sys_gstack.add_frame(sys_tid, __temp_list_args);
    } ->
    fact1_63(sys_tid);
    {  var y33_id = sys_gstack.retopr_frame(sys_tid);
    var ret34_id = call(mul, sys_gstack.frame_get(sys_tid, 0, 0), y33_id);
    sys_gstack.frame_push(sys_tid, ret34_id);
    } ->
    Skip
  }
  ;

mc_fact2_66(sys_tid) =
  {  var mc_fact2_clo21_id = sys_mylib_obj.createTuple2(2, sys_gstack.frame_get(sys_tid, 0, 2));
  var temp8_id = call(lte, sys_gstack.frame_get(sys_tid, 0, 0), 1);
  sys_gstack.frame_push(sys_tid, temp8_id);
  } ->
  if (sys_gstack.frame_get_bool(sys_tid, 0, 3)) {
    {  sys_gstack.frame_push(sys_tid, sys_gstack.frame_get(sys_tid, 0, 1));
    } ->
    Skip
  } else {
    {  var temp35_id = call(sub, sys_gstack.frame_get(sys_tid, 0, 0), 1);
    var temp36_id = call(mul, sys_gstack.frame_get(sys_tid, 0, 0), sys_gstack.frame_get(sys_tid, 0, 1));
    var __temp_list_args = sys_mylib_obj.list_nil ();
    __temp_list_args = sys_mylib_obj.list_cons (temp35_id, __temp_list_args);
    __temp_list_args = sys_mylib_obj.list_cons (temp36_id, __temp_list_args);
    __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 2), __temp_list_args);
    sys_gstack.reload_frame(sys_tid, __temp_list_args);
    } ->
    mc_fact2_66(sys_tid)
  }
  ;

main_69(sys_tid) =
  {  var main_clo23_id = sys_mylib_obj.createTuple2(3, sys_gstack.frame_get(sys_tid, 0, 0));
  var mc_fact2_66_ele24_id = sys_mylib_obj.getTupleElement(sys_gstack.frame_get(sys_tid, 0, 0), 0);;
  sys_gstack.frame_push(sys_tid, mc_fact2_66_ele24_id);
  var fact1_63_ele25_id = sys_mylib_obj.getTupleElement(sys_gstack.frame_get(sys_tid, 0, 0), 1);;
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (4, __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (fact1_63_ele25_id, __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } ->
  fact1_63(sys_tid);
  {  var x_70 = sys_gstack.retopr_frame(sys_tid);
  sys_gstack.frame_push(sys_tid, x_70);
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (4, __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (1, __temp_list_args);
  __temp_list_args = sys_mylib_obj.list_cons (sys_gstack.frame_get(sys_tid, 0, 1), __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } ->
  mc_fact2_66(sys_tid);
  {  var y_71 = sys_gstack.retopr_frame(sys_tid);
  var temp13_id = call(eq, sys_gstack.frame_get(sys_tid, 0, 2), y_71);
  sys_assert_var = temp13_id;
  } ->
  {  var temp15_id = call(eq, sys_gstack.frame_get(sys_tid, 0, 2), 23);
  sys_assert_var = temp15_id;
  } ->
  Skip
  ;

// =====================

main_s(sys_tid) = 
  main_init{var __temp_list_args = sys_mylib_obj.list_nil ();
            sys_gstack.add_frame(0, __temp_list_args); 
            } ->
  {  var env26_id = sys_mylib_obj.createTuple(0);
  var fact1_closure27_id = sys_mylib_obj.createTuple2(1, env26_id);
  var env28_id = sys_mylib_obj.createTuple(0);
  var mc_fact2_closure29_id = sys_mylib_obj.createTuple2(2, env28_id);
  var env30_id = sys_mylib_obj.createTuple(2);
  sys_mylib_obj.setTupleElement(env30_id, 0, env28_id);
  sys_mylib_obj.setTupleElement(env30_id, 1, env26_id);
  var main_closure31_id = sys_mylib_obj.createTuple2(3, env30_id);
  var __temp_list_args = sys_mylib_obj.list_nil ();
  __temp_list_args = sys_mylib_obj.list_cons (env30_id, __temp_list_args);
  sys_gstack.add_frame(sys_tid, __temp_list_args);
  } ->
  main_69(sys_tid);
  {  sys_gstack.delete_frame(sys_tid);
  } ->
  Skip; 
  proc_thread_finalize(sys_tid);

main = main_s(0) ||| Scheduler;

#define sys_assertion sys_assert_var == true;

#assert main deadlockfree;

#assert main |= G sys_assertion;


